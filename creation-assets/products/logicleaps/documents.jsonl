{"_id": "LL-CIR-001_UG_v1.0", "product_id": "LL-CIR-001", "product_name": "Logic Gate Explorer Kit", "doc_type": "User Guide", "version": "1.0", "title": "Logic Gate Explorer Kit User Guide", "language": "en-US", "format": "Markdown", "text": "# Logic Gate Explorer Kit User Guide (v1.0)\n\nDiscover the building blocks of computers!\n\n## Kit Contents\n\n*   Power Block (Battery Holder)\n*   Input Block (Button) x2\n*   AND Gate Block x1\n*   OR Gate Block x1\n*   NOT Gate Block x1\n*   Output Block (LED) x2\n*   Connector Wires / Base Grid (depending on design)\n*   *(Batteries usually not included)*\n\n*(Illustrations of each block type)*\n\n## How Logic Blocks Work\n\n*   **Concept:** These blocks represent digital logic gates. They take inputs (ON/1 or OFF/0) and produce an output (ON/1 or OFF/0) based on a specific rule.\n*   **Power Block:** Provides power (representing logical 1 or HIGH) to the circuit. Needs batteries installed correctly.\n*   **Input Blocks (Button):** Provide input signals. Pressing the button sends an ON (1) signal; releasing it sends an OFF (0) signal.\n*   **Logic Gate Blocks (AND, OR, NOT):** Process input signals according to their rules (see EPB).\n*   **Output Blocks (LED):** Show the result. Lights up when it receives an ON (1) signal.\n*   **Connections:** Use wires or snap onto a base grid to connect Output from one block to Input of the next.\n    *   Power Block Output -> Input Block Power In\n    *   Input Block Output -> Logic Gate Input\n    *   Logic Gate Output -> LED Input\n\n## Getting Started: Simple Circuit\n\n1.  **Install Batteries:** Put required batteries (e.g., AA) into the Power Block.\n2.  **Connect Power to Input:** Connect Power Block Output to one Input (Button) Block's Power In.\n3.  **Connect Input to Output:** Connect the Input Block's Output to one Output (LED) Block's Input.\n4.  **Test:** Turn on power (if switch exists). Press the button on the Input Block. The LED should light up. Release the button; the LED should turn off.\n\n## Building Logic Circuits\n\n*   Combine Input, Logic Gate, and Output blocks according to the experiments in the Experiment & Project Book (EPB).\n*   Ensure all connections are secure.\n*   Trace the signal path: Power -> Input -> Gate(s) -> Output.\n\nRefer to the Experiment & Project Book (LL-CIR-001_EPB_v1.0) for understanding logic gates and building circuits."}
{"_id": "LL-CIR-001_EPB_v1.0", "product_id": "LL-CIR-001", "product_name": "Logic Gate Explorer Kit", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Logic Gate Explorer Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Logic Gate Explorer Experiment & Project Book (v1.0)\n\nExploring AND, OR, and NOT logic.\n\n## Introduction to Digital Logic\n\n*   Digital circuits use two states: ON (represented as 1, HIGH, True) and OFF (represented as 0, LOW, False).\n*   Logic gates are fundamental building blocks that make decisions based on these ON/OFF inputs.\n\n## Experiment 1: The NOT Gate (Inverter)\n\n*   **Rule:** The NOT gate has one input and one output. The output is always the OPPOSITE of the input.\n    *   Input=0 (OFF) -> Output=1 (ON)\n    *   Input=1 (ON) -> Output=0 (OFF)\n*   **Build:** Power Block -> Input Button -> NOT Gate -> LED Output.\n    *(Diagram of this circuit)*\n*   **Observe:**\n    *   Button NOT pressed (Input=0): Is the LED ON or OFF? (Should be ON)\n    *   Button PRESSED (Input=1): Is the LED ON or OFF? (Should be OFF)\n*   **Conclusion:** The NOT gate inverts the signal.\n\n## Experiment 2: The AND Gate\n\n*   **Rule:** The AND gate has two inputs and one output. The output is ON (1) ONLY if **BOTH** Input A **AND** Input B are ON (1).\n    *   Inputs 0,0 -> Output 0\n    *   Inputs 0,1 -> Output 0\n    *   Inputs 1,0 -> Output 0\n    *   Inputs 1,1 -> Output 1\n*   **Build:** Power Block connected to TWO Input Buttons (Button A, Button B). Button A Output -> AND Gate Input A. Button B Output -> AND Gate Input B. AND Gate Output -> LED Output.\n    *(Diagram of this circuit)*\n*   **Observe (Truth Table):**\n    *   Press Neither Button (0,0): LED is OFF.\n    *   Press Button A only (1,0): LED is OFF.\n    *   Press Button B only (0,1): LED is OFF.\n    *   Press BOTH Buttons (1,1): LED is ON.\n*   **Conclusion:** AND requires all inputs to be true.\n\n## Experiment 3: The OR Gate\n\n*   **Rule:** The OR gate has two inputs and one output. The output is ON (1) if **EITHER** Input A **OR** Input B (or both) are ON (1).\n    *   Inputs 0,0 -> Output 0\n    *   Inputs 0,1 -> Output 1\n    *   Inputs 1,0 -> Output 1\n    *   Inputs 1,1 -> Output 1\n*   **Build:** Similar to AND circuit, but replace AND Gate block with OR Gate block.\n    *(Diagram of this circuit)*\n*   **Observe (Truth Table):**\n    *   Press Neither Button (0,0): LED is OFF.\n    *   Press Button A only (1,0): LED is ON.\n    *   Press Button B only (0,1): LED is ON.\n    *   Press BOTH Buttons (1,1): LED is ON.\n*   **Conclusion:** OR requires at least one input to be true.\n\n## Project Idea: Simple Alarm\n\n*   **Concept:** LED turns ON if Button A OR Button B is pressed.\n*   **Build:** Use the OR Gate circuit (Experiment 3).\n\n## Project Idea: Two-Switch Light\n\n*   **Concept:** LED turns ON only if Button A AND Button B are pressed (like a safety switch).\n*   **Build:** Use the AND Gate circuit (Experiment 2).\n\n## Challenge: Combining Gates\n*   Try connecting the output of one gate to the input of another. Example: `(Input A AND Input B) OR Input C`? How would you build this?"}
{"_id": "LL-CIR-001_SI_v1.0", "product_id": "LL-CIR-001", "product_name": "Logic Gate Explorer Kit", "doc_type": "Safety Information", "version": "1.0", "title": "Logic Gate Explorer Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# Logic Gate Explorer Kit Safety Information (v1.0)\n\nSafe handling of logic blocks.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (blocks, connectors). Not for children under 3 years.**\n*   **Recommended Age:** 7+ Adult supervision recommended.\n*   **Battery Safety:** Follow standard battery safety guidelines for the required batteries (e.g., AA) used in the Power Block (correct type, polarity, do not mix, remove when storing).\n*   **Electrical Safety:** This is a low-voltage kit operating from batteries. Components are designed for safe handling.\n    *   Do not connect to wall power outlets.\n    *   Do not short-circuit battery terminals.\n    *   Avoid contact with water.\n*   **Handling Blocks:** Connect blocks gently but firmly. Do not force connections.\n*   Keep small parts away from pets."}
{"_id": "LL-CIR-005_UG_v1.0", "product_id": "LL-CIR-005", "product_name": "Circuit City Logic Lab", "doc_type": "User Manual & Setup Guide", "version": "1.0", "title": "Circuit City Logic Lab User Manual & Setup Guide", "language": "en-US", "format": "Markdown", "text": "# Circuit City Logic Lab User Manual & Setup Guide (v1.0)\n\nBuild and simulate digital logic circuits!\n\n## Kit Contents Overview (See EPB for details)\n\n*   Base Grid / Board\n*   Power Module (USB powered)\n*   Logic Gate Modules (AND, OR, NOT, XOR)\n*   Input Modules (Button, Switch, Light Sensor)\n*   Output Modules (LED, Buzzer)\n*   Connecting Wires / Patch Cables\n*   USB Cable (for power and PC connection)\n*   Software Installation Guide / Card\n\n*(Illustrations of different module types)*\n\n## Setting Up the Hardware\n\n1.  **Place Base Grid:** Put the base grid on a flat surface.\n2.  **Connect Power Module:** Snap the Power Module onto the grid. Connect the USB cable from the Power Module to a USB port on your computer OR a USB power adapter (for power only, PC connection needed for simulation).\n3.  **Power On:** Turn on the power switch on the Power Module. A power indicator light should illuminate.\n\n## Connecting Modules\n\n*   **Placement:** Snap desired Input, Logic Gate, and Output modules onto the base grid.\n*   **Wiring:** Use the provided wires/cables to connect the modules.\n    *   **Power:** Connect Power Output (+) from the Power Module to the Power Input (+) of each module you want to use. Connect Power Ground (-) similarly.\n    *   **Signal:** Connect the Output terminal of one module (e.g., Button Output) to the Input terminal of the next module (e.g., AND Gate Input A). Outputs can often connect to multiple inputs.\n    *(Diagram: Shows example wiring for Power (+/-) and Signal paths)*\n*   **Inputs/Outputs:** Logic gates typically have multiple inputs (A, B) and one output (Q). Input modules have outputs. Output modules have inputs.\n\n## Basic Operation (Hardware Only)\n\n1.  Build a simple circuit (e.g., Power -> Button -> LED).\n2.  Ensure all power (+) and ground (-) connections are made correctly to the active modules.\n3.  Operate the input module (press button). The output module (LED) should react based on the circuit logic.\n\n## Connecting to PC Software (Simulation)\n\n1.  **Install Software:** Install the 'Circuit City Simulator' software from the included SD card/download link onto your computer (Windows/Mac).\n2.  **Connect USB:** Ensure the Power Module's USB cable is connected to your computer (provides both power and data connection).\n3.  **Launch Software:** Start the Circuit City Simulator software.\n4.  **Detection:** The software should automatically detect the connected Logic Lab hardware via USB.\n\n## Software Overview\n\n*   The software provides a virtual representation of your hardware setup.\n*   It allows simulating circuits before building them physically.\n*   It offers guided tutorials and challenges.\n*   Refer to the Software Guide (LL-CIR-005_SWG_v1.0) for detailed software usage.\n\nSee the Experiment & Project Book (EPB) for circuit ideas and logic explanations."}
{"_id": "LL-CIR-005_EPB_v1.1", "product_id": "LL-CIR-005", "product_name": "Circuit City Logic Lab", "doc_type": "Experiment & Project Book", "version": "1.1", "title": "Circuit City Logic Lab Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Circuit City Logic Lab Experiment & Project Book (v1.1)\n\nBuilding and understanding digital logic circuits.\n\n## Introduction\n\n*   Review of Digital Logic states (0/LOW, 1/HIGH) and basic gates (AND, OR, NOT - see LL-CIR-001 EPB if needed).\n*   Introduction to new components in this kit.\n\n## New Logic Gate: XOR (Exclusive OR)\n\n*   **Rule:** The XOR gate has two inputs and one output. The output is ON (1) if **EITHER** Input A **OR** Input B is ON (1), **BUT NOT BOTH**.\n    *   Inputs 0,0 -> Output 0\n    *   Inputs 0,1 -> Output 1\n    *   Inputs 1,0 -> Output 1\n    *   Inputs 1,1 -> Output 0\n*   **Experiment 4: The XOR Gate:**\n    *   **Build:** Power -> 2 Buttons (A, B). A -> XOR Input A. B -> XOR Input B. XOR Output -> LED.\n    *(Diagram of XOR circuit)*\n    *   **Observe (Truth Table):** Test all four input combinations and verify the LED output matches the XOR rule.\n*   **Use Case:** Often used in circuits that compare inputs or perform binary addition.\n\n## New Input Module: Light Sensor\n\n*   **Function:** Outputs a digital signal (0 or 1) based on ambient light level.\n    *   Bright Light -> Output 0 (or 1 - check module spec! Let's assume 0 for bright)\n    *   Dark -> Output 1 (or 0 - let's assume 1 for dark)\n*   **Experiment 5: Light Activated LED:**\n    *   **Build:** Power -> Light Sensor -> LED.\n    *   **Observe:** Cover the sensor (make it dark). Does the LED turn ON? Shine light on sensor. Does the LED turn OFF? (Based on assumed logic).\n    *   **(Optional Inversion):** Build Power -> Light Sensor -> NOT Gate -> LED. Observe the opposite behavior.\n\n## New Output Module: Buzzer\n\n*   **Function:** Makes a buzzing sound when its input receives an ON (1) signal.\n*   **Experiment 6: Button-Activated Buzzer:**\n    *   **Build:** Power -> Button -> Buzzer.\n    *   **Observe:** Press the button. The buzzer should sound.\n\n## Combining Components: Example Projects\n\n*   **Project: Darkness Alarm**\n    *   **Goal:** Buzzer sounds when it gets dark.\n    *   **Build:** Power -> Light Sensor -> Buzzer. (Or add NOT gate if sensor logic is inverted: Power -> Light Sensor -> NOT Gate -> Buzzer).\n*   **Project: Two-Key Security Alert**\n    *   **Goal:** Buzzer sounds only if Button A AND Button B are pressed simultaneously.\n    *   **Build:** Power -> Button A -> AND Gate Input A. Power -> Button B -> AND Gate Input B. AND Gate Output -> Buzzer.\n*   **Project: Light-OR-Button Activated Light**\n    *   **Goal:** LED turns on if it's dark OR if a button is pressed.\n    *   **Build:** Power -> Light Sensor -> OR Gate Input A. Power -> Button -> OR Gate Input B. OR Gate Output -> LED.\n\n## Introduction to Boolean Algebra\n\n*   Brief explanation of representing logic gates with symbols and equations:\n    *   NOT A: `A'` or `¬A` or `!A`\n    *   A AND B: `A · B` or `A ∧ B` or `A && B`\n    *   A OR B: `A + B` or `A ∨ B` or `A || B`\n    *   A XOR B: `A ⊕ B`\n*   Show truth tables alongside symbols.\n\nUse the PC Software (see SWG) to simulate these circuits and tackle more complex challenges!"}
{"_id": "LL-CIR-005_SWG_v1.0", "product_id": "LL-CIR-005", "product_name": "Circuit City Logic Lab", "doc_type": "Software Guide", "version": "1.0", "title": "Circuit City Simulator Software Guide", "language": "en-US", "format": "Markdown", "text": "# Circuit City Simulator Software Guide (v1.0)\n\nSimulate, test, and learn digital logic on your PC.\n\n## Software Installation & Setup\n\n1.  Install software from included media/download.\n2.  Connect Logic Lab hardware to PC via USB.\n3.  Launch the Circuit City Simulator software.\n4.  Ensure software detects the hardware (status indicator usually shown).\n\n## Interface Overview\n\n*(Screenshot: Simulator interface showing virtual components, wiring area, simulation controls)*\n\n*   **Component Library:** Panel listing available virtual components (Gates, Inputs, Outputs mirroring the hardware kit).\n*   **Workspace:** Main area where you drag and drop virtual components to build circuits.\n*   **Wiring Tool:** Select tool to draw virtual wires connecting component terminals.\n*   **Simulation Controls:** Start/Stop Simulation, Step Simulation (advance one logic step), Reset.\n*   **Virtual Inputs:** Click virtual buttons/switches or adjust sliders for virtual sensors to change input states during simulation.\n*   **Virtual Outputs:** Virtual LEDs light up, virtual buzzers show activation state when simulation runs.\n*   **Hardware Sync (Optional):** Some simulators might reflect the state of the physical hardware in real-time or allow downloading virtual circuits to run on the hardware (check specific features).\n*   **Tutorials/Challenges:** Built-in lessons and puzzles.\n\n## Building a Virtual Circuit\n\n1.  **Drag Components:** Drag required components (e.g., Power Source, Button, AND Gate, LED) from the Library onto the Workspace.\n2.  **Arrange Components:** Position them logically.\n3.  **Wire Connections:** Select the Wiring Tool. Click-and-drag from an output terminal (e.g., Button Output) to an input terminal (e.g., AND Gate Input A). A virtual wire appears.\n4.  **Complete Wiring:** Wire all necessary power, ground, and signal paths just like on the hardware.\n\n## Running a Simulation\n\n1.  **Start Simulation:** Click the 'Start Simulation' button.\n2.  **Interact with Inputs:** Click the virtual Button component on the workspace. Observe how its output state changes.\n3.  **Observe Logic Flow:** Watch how the output states of logic gates change based on their inputs.\n4.  **Observe Outputs:** See if the virtual LED lights up according to the circuit's logic.\n5.  **Stop Simulation:** Click 'Stop Simulation'.\n\n## Using Tutorials & Challenges\n\n*   Navigate to the Tutorials or Challenges section.\n*   Follow the on-screen instructions. These often involve building a specific circuit to meet a goal or understanding a logic concept through guided simulation.\n\n## Benefits of Simulation\n\n*   **Test Before Building:** Design and debug circuits virtually before wiring them physically.\n*   **Visualize Logic:** Clearly see signal states (0 or 1) propagating through the circuit during simulation.\n*   **Explore Complex Circuits:** Build larger circuits than might be easy to manage physically.\n*   **Learn Systematically:** Follow structured tutorials and challenges.\n\nExperiment with building all the circuits from the Experiment & Project Book (EPB) in the simulator!"}
{"_id": "LL-CIR-005_FAQ_v1.2", "product_id": "LL-CIR-005", "product_name": "Circuit City Logic Lab", "doc_type": "Troubleshooting FAQ", "version": "1.2", "title": "Circuit City Logic Lab Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# Circuit City Logic Lab Troubleshooting FAQ (v1.2)\n\nSolving common Logic Lab problems.\n\n## Hardware Issues\n\n*   **Module(s) Not Powering On (No Lights):**\n    *   Check USB connection from Power Module to computer/power adapter.\n    *   Ensure Power Module switch is ON.\n    *   Verify Power (+) and Ground (-) wires are correctly connected from Power Module output to the affected module's power inputs.\n    *   Try powering only one module directly from Power Module to isolate issue.\n*   **Circuit Not Behaving As Expected (LED always on/off, etc.):**\n    *   **Wiring Error:** Double-check ALL signal wire connections against your intended circuit diagram. Are outputs connected to inputs correctly?\n    *   **Incorrect Logic:** Rethink the logic. Are you using the right gates for the desired outcome? (e.g., used AND instead of OR).\n    *   **Floating Inputs:** Ensure EVERY input on EVERY gate used in the circuit is connected to a defined output (from Power, Ground, an Input module, or another gate's output). Unconnected inputs behave unpredictably.\n    *   **Power/Ground Missing:** Ensure EVERY module in the active circuit has BOTH Power (+) and Ground (-) connected.\n    *   Possible faulty module (try swapping with identical module if available).\n*   **Buzzer Very Quiet / LED Dim:** Insufficient power? Try powering fewer modules. Check battery level if using portable power bank.\n\n## Software / Simulation Issues\n\n*   **Hardware Not Detected by Simulator Software:**\n    *   Ensure Logic Lab USB is plugged into PC.\n    *   Check if drivers installed correctly (if needed).\n    *   Try different USB port/cable.\n    *   Restart software and hardware.\n    *   Ensure no other software is trying to access the USB device.\n*   **Virtual Circuit Simulation Incorrect:**\n    *   Double-check virtual wiring in the simulator workspace.\n    *   Ensure using correct virtual components.\n    *   Step through simulation slowly to watch logic states change.\n*   **Software Crashing / Freezing:**\n    *   Check PC minimum requirements.\n    *   Close other applications.\n    *   Update software and graphics drivers.\n    *   Reinstall software.\n*   **Hardware Sync Issues (If Applicable):**\n    *   Ensure stable USB connection.\n    *   Check sync settings in software.\n    *   May be limitations in real-time sync speed.\n\n## General Tips\n\n*   **Build Incrementally:** Add one gate or module at a time and test its function before adding more.\n*   **Label Wires:** Use different colored wires (if provided) for Power, Ground, and Signals to make circuits easier to follow and debug.\n*   **Consult EPB/SWG:** Refer back to the Experiment Book for logic rules and the Software Guide for simulator usage.\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with model (LL-CIR-005), software version, OS, and detailed problem description."}
{"_id": "LL-CIR-005_SI_v1.0", "product_id": "LL-CIR-005", "product_name": "Circuit City Logic Lab", "doc_type": "Safety Information", "version": "1.0", "title": "Circuit City Logic Lab Safety Information", "language": "en-US", "format": "Markdown", "text": "# Circuit City Logic Lab Safety Information (v1.0)\n\nSafe use of your logic lab kit.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (modules, wires). Not for children under 3 years.**\n*   **Recommended Age:** 9+ Adult supervision recommended.\n*   **Electrical Safety:** This kit operates at safe, low DC voltage (typically 5V) supplied via USB.\n    *   Use only the provided USB cable and connect to a standard computer USB port or a certified USB power adapter (5V DC, min 500mA recommended).\n    *   Do not connect to any other power source.\n    *   Avoid short circuits (e.g., connecting Power (+) directly to Ground (-)). While unlikely to cause harm at this voltage, it could damage the Power Module or USB port.\n    *   Do not expose modules or base grid to water or liquids.\n    *   Handle modules by plastic casing; avoid touching exposed pins when powered (though voltage is low).\n*   **Handling Components:** Connect modules and wires gently. Do not force connections.\n*   Keep small parts away from pets."}
{"_id": "LL-CIR-006_UG_v1.0", "product_id": "LL-CIR-006", "product_name": "Advanced Logic Systems Kit", "doc_type": "User Manual & Setup Guide", "version": "1.0", "title": "Advanced Logic Systems Kit User Manual & Setup Guide", "language": "en-US", "format": "Markdown", "text": "# Advanced Logic Systems Kit User Manual & Setup Guide (v1.0)\n\nExploring sequential logic and complex circuits.\n\n## Kit Contents Overview (See EPB for details)\n\n*   (Includes base components like LL-CIR-005: Base Grid, Power Module, Basic Gates, Inputs/Outputs)\n*   **New Modules:**\n    *   Flip-Flop Modules (e.g., D-Type, JK-Type)\n    *   Counter Modules (e.g., 4-bit Binary Counter)\n    *   Register Modules (e.g., 4-bit Shift Register)\n    *   Clock Module (Provides timed pulses)\n    *   (Possibly: Multiplexer, Demultiplexer, Adder Modules)\n*   More Connecting Wires / Patch Cables\n*   USB Cable\n*   Software Installation Guide / Card\n\n*(Illustrations of new module types)*\n\n## Setup & Connection\n\n*   **Hardware Setup:** Same as LL-CIR-005. Place Base Grid, connect Power Module via USB to PC/Power.\n*   **Module Placement & Wiring:** Snap new modules (Flip-Flops, Counters, Clock, etc.) onto the grid alongside basic gates/inputs/outputs. Wire Power (+) and Ground (-) to all modules. Connect signal wires based on the circuit being built (outputs to inputs).\n    *   **Clock Signal:** The Clock Module output provides a pulsing signal (0-1-0-1...) needed to operate sequential logic like counters and registers. Connect Clock Module output to the 'CLK' or 'Clock' input pin of these modules.\n    *   **Flip-Flop Inputs:** Connect Data (D), Set (S), Reset (R), J, K inputs as required by the experiment.\n    *   **Counter/Register Inputs:** Connect Clock, Reset, Enable inputs as needed.\n    *(Diagram: Shows example wiring including Clock signal)*\n\n## Connecting to PC Software\n\n*   Same as LL-CIR-005. Install 'Advanced Logic Simulator' software (may be same software as Circuit City with advanced components enabled). Connect via USB. Launch software.\n\n## Basic Operation\n\n*   Sequential logic circuits (counters, flip-flops) change state based on BOTH their current inputs AND their previous state, usually synchronized by a clock pulse.\n*   Build circuits as described in the Experiment & Project Book (EPB).\n*   Observe how outputs change on each pulse from the Clock Module.\n\nRefer to EPB (LL-CIR-006_EPB_v1.0) for understanding sequential logic and circuits. Refer to Software Guide (LL-CIR-006_SWG_v1.0) for simulation."}
{"_id": "LL-CIR-006_EPB_v1.0", "product_id": "LL-CIR-006", "product_name": "Advanced Logic Systems Kit", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Advanced Logic Systems Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Advanced Logic Systems Experiment & Project Book (v1.0)\n\nDiving into sequential logic and memory elements.\n\n## Introduction to Sequential Logic\n\n*   **Combinational vs. Sequential:** Basic gates (AND, OR, NOT) are combinational - output depends ONLY on current inputs. Sequential circuits have memory - output depends on current inputs AND past sequence of inputs (stored state).\n*   **Clock Signal:** Sequential circuits often use a clock signal (pulsing 0-1-0-1...) to synchronize state changes.\n*   **Flip-Flops:** The fundamental memory element. Can store a single bit (0 or 1).\n\n## Experiment 1: The D-Type Flip-Flop (Data Latch)\n\n*   **Function:** Stores the value present at the Data (D) input when the Clock (CLK) input transitions (e.g., from 0 to 1). Output (Q) holds this stored value until the next clock edge.\n*   **Inputs:** D (Data), CLK (Clock), often Reset (R) or Set (S).\n*   **Output:** Q (Stored Value), Q' (Inverted Stored Value).\n*   **Build:** Power -> Button -> D input. Power -> Clock Module -> CLK input. Q output -> LED.\n    *(Diagram of D Flip-Flop circuit)*\n*   **Observe:**\n    1.  Hold Button DOWN (D=1). Pulse the Clock (or wait for next pulse). LED (Q) should turn ON and STAY ON even if you release the button.\n    2.  Hold Button UP (D=0). Pulse the Clock. LED (Q) should turn OFF and STAY OFF.\n*   **Conclusion:** D Flip-Flop samples and holds the D input value on the clock edge.\n\n## Experiment 2: The Binary Counter\n\n*   **Function:** Counts clock pulses in binary.\nA 4-bit counter has 4 outputs (Q0, Q1, Q2, Q3) representing a binary number from 0000 (0) to 1111 (15).\n*   **Inputs:** CLK (Clock), Reset (RST - sets count to 0).\n*   **Outputs:** Q0 (Least Significant Bit), Q1, Q2, Q3 (Most Significant Bit).\n*   **Build:** Power -> Clock Module -> CLK input. Power -> Button -> Reset input (Active Low/High? Check module). Outputs Q0, Q1, Q2, Q3 -> Four LEDs.\n    *(Diagram of Counter circuit)*\n*   **Observe:** Press Reset button briefly. All LEDs off (0000). As Clock Module pulses, watch the LEDs count up in binary sequence (0001, 0010, 0011, 0100...).\n*   **Conclusion:** Counters use flip-flops internally to increment a stored binary value on each clock pulse.\n\n## Experiment 3: The Shift Register\n\n*   **Function:** Stores multiple bits and can shift them left or right on clock pulses. Used for serial-to-parallel data conversion or temporary storage.\n*   **Inputs:** Data In (Serial Data), CLK (Clock), Load/Shift control, Reset.\n*   **Outputs:** Parallel Outputs (Q0, Q1, Q2, Q3...), Serial Out.\n*   **Build:** (Simplified Example - Serial In, Parallel Out)\n    *   Power -> Button -> Data In. Power -> Clock Module -> CLK.\n    *   Shift Register Outputs Q0-Q3 -> Four LEDs.\n    *(Diagram of Shift Register circuit)*\n*   **Observe:**\n    1.  Set Button state (0 or 1).\n    2.  Pulse Clock. The input value appears at Q0 LED. Previous Q0 moves to Q1, etc.\n    3.  Repeat setting input and pulsing clock to shift data through the register LEDs.\n*   **Conclusion:** Shift registers move data bit-by-bit through storage elements.\n\n## Project Ideas\n\n*   **Traffic Light Sequencer:** Use counter outputs and logic gates to control Red/Yellow/Green LEDs in sequence.\n*   **Simple Memory:** Use D Flip-Flops to store a 4-bit number entered via buttons.\n*   **Knight Rider Scanner:** Use shift register and clock to make LEDs light up back and forth.\n\nExplore further using the simulator!"}
{"_id": "LL-CIR-006_SWG_v1.0", "product_id": "LL-CIR-006", "product_name": "Advanced Logic Systems Kit", "doc_type": "Software Guide", "version": "1.0", "title": "Advanced Logic Simulator Software Guide", "language": "en-US", "format": "Markdown", "text": "# Advanced Logic Simulator Software Guide (v1.0)\n\nSimulating sequential circuits and complex logic.\n\n## Software Setup & Hardware Connection\n\n*   (Same as LL-CIR-005_SWG_v1.0: Install, Connect USB, Launch, Detect Hardware).\n*   The simulator library now includes advanced components.\n\n## Advanced Components in Simulator Library\n\n*(Screenshot: Component Library showing Flip-Flops, Counters, Registers, Clock)*\n\n*   **Clock Source:** Virtual clock generator. Set frequency (speed of pulses).\n*   **Flip-Flops:** D-Type, JK-Type, T-Type available virtually.\n*   **Counters:** Binary counters, Decade counters.\n*   **Registers:** Shift registers (Serial-In/Parallel-Out, Parallel-In/Serial-Out).\n*   **Multiplexers (MUX):** Select one of several inputs based on control signals.\n*   **Demultiplexers (DEMUX):** Route single input to one of several outputs.\n*   **Adders:** Perform binary addition.\n*   **(Other standard logic IC simulations might be included, e.g., 555 Timer).**\n\n## Building Sequential Circuits in Simulation\n\n1.  **Drag Components:** Place required components (Clock, Flip-Flops, Counters, Gates, Inputs, Outputs) onto workspace.\n2.  **Wire Connections:** Use Wiring Tool to connect terminals.\n    *   **CRITICAL:** Connect the virtual Clock Source output to the CLK input of all sequential components (Flip-Flops, Counters, Registers) that need to be synchronized.\n    *   Connect Data, Set, Reset, Enable inputs as needed.\n    *   Connect outputs (Q, Q') to LEDs or inputs of other components.\n\n## Running Sequential Simulations\n\n*   **Start Simulation:** Click 'Start'.\n*   **Observe Clock:** See the Clock source pulsing.\n*   **Watch State Changes:** Observe how Flip-Flop outputs (Q) change only on the clock edge based on their inputs (D, J, K, T).\n*   **Observe Counters:** Watch the binary output LEDs increment with each clock pulse.\n*   **Interact with Inputs:** Change virtual button/switch states connected to D, J, K, Set, Reset inputs *between* clock pulses and see the effect on the *next* clock edge.\n*   **Step Simulation:** Use 'Step' button to advance the simulation one clock cycle at a time for detailed analysis.\n\n## Using Challenges & Tutorials\n\n*   The software likely includes advanced tutorials explaining flip-flop behavior, counter design, register operation, etc.\n*   Challenges might involve building circuits to perform specific counting sequences, data storage, or simple state machines.\n\n## Tips for Advanced Simulation\n\n*   **Timing Diagrams:** Some advanced simulators can generate timing diagrams showing how signals (Clock, Inputs, Outputs) change over time. Very useful for debugging sequential logic.\n*   **Probes:** Use virtual 'probes' to monitor the logic state (0 or 1) at any wire connection point during simulation.\n*   **Modularity:** Build and test smaller sub-circuits (like a single flip-flop setup) before combining them into larger designs.\n\nMaster the fundamentals of how computers count and store information!"}
{"_id": "LL-CIR-006_FAQ_v1.0", "product_id": "LL-CIR-006", "product_name": "Advanced Logic Systems Kit", "doc_type": "Troubleshooting FAQ", "version": "1.0", "title": "Advanced Logic Systems Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# Advanced Logic Systems Troubleshooting FAQ (v1.0)\n\nDebugging sequential logic circuits.\n\n## Hardware & Circuit Issues\n\n*   **(Basic Issues: Power, Wiring, Basic Gates):** Refer to LL-CIR-005_FAQ_v1.2.\n*   **Flip-Flop Not Storing Data / Output Not Changing:**\n    *   **Check Clock Connection:** Ensure the Clock Module output is firmly connected to the Flip-Flop's CLK input.\n    *   **Check Power/Ground:** Verify Flip-Flop module has power.\n    *   **Check Data/Control Inputs:** Ensure the D, J, K, T inputs are connected to a valid logic level (0 or 1 from a source). Floating inputs cause unpredictable behavior.\n    *   **Check Set/Reset Inputs:** Ensure asynchronous Set/Reset inputs (if present) are not being held active, forcing the output state. They are often 'active low' (need to be HIGH for normal operation).\n*   **Counter Not Counting / Counting Incorrectly:**\n    *   **Check Clock Connection:** Essential for counting.\n    *   **Check Reset Connection:** Ensure Reset pin is not held active (often active low).\n    *   **Check Enable Pin (if present):** Ensure Counter Enable pin is active (e.g., HIGH) to allow counting.\n    *   **Wiring Error on Outputs:** Double-check Q0-Q3 outputs are wired correctly to LEDs or subsequent logic.\n    *   **Clock Speed Too High?** (Unlikely with module, but possible in complex circuits) Flip-flops might miss pulses.\n*   **Shift Register Not Shifting:**\n    *   **Check Clock Connection.**\n    *   **Check Serial Data Input:** Ensure data is present at the input *before* the clock pulse arrives.\n    *   **Check Load/Shift Control Pin:** Ensure pin is set to 'Shift' mode (not 'Load' mode, if applicable).\n    *   **Check Reset Pin.**\n*   **Circuit Behaves Erratically / Race Conditions:**\n    *   In complex circuits with feedback loops or multiple paths, timing differences can cause unexpected behavior (race conditions). This is harder to debug physically; simulation is helpful.\n    *   Ensure all sequential elements share the SAME clock signal.\n\n## Software / Simulation Issues\n\n*   **(General Simulator Issues: Detection, Crashing):** Refer to LL-CIR-005_FAQ_v1.2.\n*   **Sequential Components Not Working in Sim:**\n    *   **Clock Not Connected:** MUST connect virtual Clock Source to CLK inputs.\n    *   **Inputs Floating:** All virtual inputs (D, J, K, Set, Reset, Enable) must be connected to a defined virtual source (Switch, Logic High/Low source, Gate Output).\n    *   **Incorrect Component Type:** Ensure using correct flip-flop type (D, JK, T) for the intended logic.\n*   **Simulation Runs Too Fast/Slow:** Adjust simulation speed or clock frequency in software settings.\n\n## General Tips\n\n*   **Understand the Component:** Before using a Flip-Flop, Counter, or Register, review its truth table or function table in the EPB to understand exactly how its inputs affect its outputs on the clock edge.\n*   **Test Incrementally:** Build and test one sequential element at a time.\n*   **Use the Simulator:** Debug complex sequential logic in the simulator first, using stepping and probes, before building physically.\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with model (LL-CIR-006), software version, OS, and detailed problem description."}
{"_id": "LL-CIR-006_SI_v1.0", "product_id": "LL-CIR-006", "product_name": "Advanced Logic Systems Kit", "doc_type": "Safety Information", "version": "1.0", "title": "Advanced Logic Systems Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# Advanced Logic Systems Kit Safety Information (v1.0)\n\nSafe use of your advanced logic kit.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (modules, wires). Not for children under 3 years.**\n*   **Recommended Age:** 11+ Adult supervision recommended.\n*   **Electrical Safety:** Operates at safe, low DC voltage (typically 5V) via USB.\n    *   Use only the provided USB cable and connect to a standard computer USB port or a certified USB power adapter (5V DC).\n    *   Do not connect to any other power source.\n    *   Avoid short circuits.\n    *   Do not expose modules or base grid to water or liquids.\n*   **Handling Components:** Connect modules and wires gently. Do not force connections. Handle modules by plastic casing.\n*   Keep small parts away from pets."}
{"_id": "LL-MCU-001_UG_v1.0", "product_id": "LL-MCU-001", "product_name": "MicroController Starter Kit (KinetiCore Uno)", "doc_type": "User Guide", "version": "1.0", "title": "MicroController Starter Kit (KinetiCore Uno) User Guide", "language": "en-US", "format": "Markdown", "text": "# MicroController Starter Kit (KinetiCore Uno) User Guide (v1.0)\n\nYour first steps into microcontroller programming!\n\n## Kit Contents Overview\n\n*   KinetiCore Uno Microcontroller Board (Arduino UNO compatible)\n*   USB Cable (Type A to Type B)\n*   Half-Size Breadboard\n*   Assortment of Jumper Wires (Male-Male)\n*   Basic Components:\n    *   LEDs (Various colors)\n    *   Resistors (Various values, e.g., 220 Ohm, 10k Ohm)\n    *   Push Buttons\n    *   Potentiometer (Variable Resistor)\n    *   Photoresistor (Light Sensor)\n    *   Temperature Sensor (e.g., TMP36)\n    *   (Maybe: Buzzer, Small Servo)\n*   Software Info Card (for Kinetic Blocks IDE)\n\n*(Illustrations: KinetiCore Uno board layout with pin labels, Breadboard layout)*\n\n## Understanding the KinetiCore Uno Board\n\n*   **Microcontroller:** The 'brain' chip (e.g., ATmega328P) that runs your code.\n*   **USB Port:** Connects to computer for programming and power.\n*   **Power Jack (Optional):** Can power the board from external adapter (usually not needed when USB connected).\n*   **Digital Pins (0-13):** Can be configured as Inputs or Outputs. Send/receive digital signals (HIGH/5V or LOW/0V).\n*   **Analog Pins (A0-A5):** Can read analog sensor values (voltages between 0V and 5V).\n*   **Power Pins (5V, 3.3V, GND, VIN):** Provide power to external components on breadboard.\n*   **Reset Button:** Restarts the program loaded on the board.\n*   **LEDs:** Built-in LEDs for Power (ON), Transmit/Receive (TX/RX - blink during code upload), Pin 13 (controllable in code).\n\n## Understanding the Breadboard\n\n*   **No Soldering Needed:** Allows temporary connections for circuits.\n*   **Rows:** Holes in horizontal rows (across the short side) are electrically connected internally.\n*   **Power Rails:** Long vertical strips along the sides (often marked + and -) are connected vertically. Used for distributing power (5V/GND) across the board.\n*   **Center Divide:** Separates the left and right halves of the horizontal rows.\n\n## Software Setup\n\n1.  **Install IDE:** Download and install the 'Kinetic Blocks IDE' (Integrated Development Environment) software from Kinetic Constructs website onto your computer (Windows/Mac/Linux).\n2.  **Install Drivers:** Connect the KinetiCore Uno board to your PC via USB. Your OS may automatically install drivers, or you might need to install CH340/FTDI drivers (check IDE setup guide).\n3.  **Launch IDE:** Open Kinetic Blocks IDE.\n4.  **Configure IDE:**\n    *   **Board Selection:** Go to Tools > Board menu and select \"KinetiCore Uno\" (or \"Arduino Uno\").\n    *   **Port Selection:** Go to Tools > Port menu and select the COM port (Windows) or /dev/tty port (Mac/Linux) that the KinetiCore Uno is connected to.\n\n## First Program: Blinking LED\n\n*   The IDE usually opens with a basic 'Blink' example.\n*   This example uses block code to turn the built-in LED (Pin 13) ON, wait, turn it OFF, wait, and repeat.\n*   **Upload Code:** Click the 'Upload' button (often an arrow icon) in the IDE.\n*   **Observe:** The IDE will compile the block code and upload it to the KinetiCore Uno board via USB. Watch the TX/RX lights blink during upload. After upload, the Pin 13 LED on the board should start blinking.\n\nRefer to the Experiment & Project Book (EPB) and Block Coding Guide (BCG) for building circuits and writing code."}
{"_id": "LL-MCU-001_EPB_v1.0", "product_id": "LL-MCU-001", "product_name": "MicroController Starter Kit (KinetiCore Uno)", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "MicroController Starter Kit Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# MicroController Starter Kit Experiment & Project Book (v1.0)\n\nBringing circuits to life with code!\n\n## Introduction to Microcontrollers\n\n*   **What is a Microcontroller?** A small computer on a single chip containing a processor, memory, and input/output peripherals. It can be programmed to interact with electronic components.\n*   **KinetiCore Uno (Arduino Based):** Uses a popular, easy-to-learn platform.\n*   **Programming:** We'll use Kinetic Blocks IDE (block-based coding) to write instructions (called 'sketches' or programs).\n*   **Hardware Interaction:** Code tells the microcontroller how to read inputs (buttons, sensors) connected to its pins and control outputs (LEDs, buzzers) connected to its pins.\n*   **Breadboarding:** Building temporary circuits to connect components to the KinetiCore Uno.\n\n## Basic Electronics Review\n\n*   **Voltage (V):** Electrical potential difference (KinetiCore uses 5V or 3.3V).\n*   **Current (I):** Flow of electrical charge.\n*   **Resistance (R):** Opposition to current flow (measured in Ohms Ω).\n*   **LEDs:** Light Emitting Diodes. Need current-limiting resistors to prevent burning out. Long leg (anode) connects towards positive (+), short leg (cathode) connects towards ground (-).\n*   **Resistors:** Limit current flow. Color bands indicate resistance value (or use multimeter).\n*   **Buttons:** Create connection when pressed.\n*   **Breadboard Connections:** Rows connected horizontally, power rails vertically.\n\n## Experiment 1: Blinking an External LED\n\n*   **Goal:** Blink an LED connected to a digital pin.\n*   **Circuit:**\n    1.  Connect KinetiCore Uno GND pin to breadboard '-' rail.\n    2.  Connect KinetiCore Uno Pin 8 to one leg of a 220Ω resistor on breadboard.\n    3.  Connect other leg of resistor to LED's long leg (anode).\n    4.  Connect LED's short leg (cathode) to breadboard '-' rail (GND).\n    *(Diagram of this breadboard circuit)*\n*   **Code (Block):** (Refer to BCG for specific blocks)\n    *   Setup: Set Pin 8 as OUTPUT.\n    *   Loop: Turn Pin 8 HIGH, Wait 1000ms, Turn Pin 8 LOW, Wait 1000ms.\n*   **Upload & Observe:** Upload code. External LED should blink.\n\n## Experiment 2: Reading a Button Press\n\n*   **Goal:** Turn on LED when button is pressed.\n*   **Circuit:**\n    1.  Setup LED circuit as in Exp 1 (Pin 8).\n    2.  Connect KinetiCore Uno 5V pin to breadboard '+' rail.\n    3.  Place button across breadboard center gap.\n    4.  Connect one button leg (e.g., top-left) to breadboard '+' rail (5V).\n    5.  Connect diagonally opposite leg (e.g., bottom-right) to KinetiCore Uno Pin 2.\n    6.  Connect SAME button leg (bottom-right) through a 10kΩ resistor to breadboard '-' rail (GND) - This is a PULL-DOWN resistor.\n    *(Diagram of button circuit with pull-down)*\n*   **Code (Block):**\n    *   Setup: Set Pin 8 as OUTPUT, Set Pin 2 as INPUT.\n    *   Loop: Read state of Pin 2. If Pin 2 is HIGH, Turn Pin 8 HIGH. Else, Turn Pin 8 LOW.\n*   **Upload & Observe:** Upload. LED should turn ON only when button is pressed.\n\n## Experiment 3: Fading an LED (PWM)\n\n*   **Goal:** Make LED fade in and out smoothly.\n*   **Circuit:** Same as Exp 1, but connect resistor/LED to a PWM pin (marked with '~', e.g., Pin ~9).\n*   **Code (Block):**\n    *   Setup: Set Pin 9 as OUTPUT.\n    *   Loop: Use 'Analog Write (PWM)' block. Loop a variable (e.g., 'brightness') from 0 to 255, setting Pin 9 to 'brightness'. Add small delay. Loop 'brightness' back down from 255 to 0.\n*   **Upload & Observe:** LED should smoothly fade in and out.\n\n## Experiment 4: Reading Analog Sensor (Photoresistor)\n\n*   **Goal:** Read light level and print to Serial Monitor.\n*   **Circuit (Voltage Divider):**\n    1.  Connect 5V to '+' rail, GND to '-' rail.\n    2.  Connect Photoresistor from '+' rail to a central row.\n    3.  Connect 10kΩ resistor from SAME central row to '-' rail (GND).\n    4.  Connect KinetiCore Uno Analog Pin A0 to the SAME central row (junction between photoresistor and fixed resistor).\n    *(Diagram of voltage divider with photoresistor)*\n*   **Code (Block):**\n    *   Setup: Initialize Serial Communication (9600 baud).\n    *   Loop: Read Analog value from Pin A0 into variable 'lightLevel'. Print 'lightLevel' value to Serial Monitor. Wait 100ms.\n*   **Upload & Observe:** Upload code. Open Serial Monitor in IDE (Tools > Serial Monitor). Observe numbers change as you cover/uncover the photoresistor.\n\n*(Include experiments for Temp Sensor, Potentiometer, Buzzer, Servo if included)*\n\nKeep exploring and combining these concepts!"}
{"_id": "LL-MCU-001_BCG_v1.0", "product_id": "LL-MCU-001", "product_name": "MicroController Starter Kit (KinetiCore Uno)", "doc_type": "Block Coding Guide", "version": "1.0", "title": "Kinetic Blocks IDE Block Coding Guide (for Uno)", "language": "en-US", "format": "Markdown", "text": "# Kinetic Blocks IDE Block Coding Guide (for Uno) (v1.0)\n\nProgramming your KinetiCore Uno with drag-and-drop blocks.\n\n## IDE Interface Overview\n\n*(Screenshot: Kinetic Blocks IDE showing Block Categories, Workspace, Code Preview, Upload Button, Serial Monitor Button)*\n\n*   **Block Categories:** Palettes on the left containing blocks for Control, Logic, Math, Variables, Pins (Input/Output), Sensors, Communication, etc.\n*   **Workspace:** Main area where you drag blocks from palettes and snap them together to build your program.\n*   **Code Preview (Optional):** May show the underlying Arduino C++ code generated from the blocks.\n*   **Upload Button:** Compiles blocks into machine code and sends it to the connected KinetiCore Uno board.\n*   **Serial Monitor Button:** Opens a window to view data printed from the board (using Serial Print blocks) or send data to the board.\n*   **Board/Port Selection:** Menus (usually under Tools) to select \"KinetiCore Uno\" (or Arduino Uno) and the correct COM/tty Port.\n\n## Basic Program Structure\n\n*   Most programs use two main structure blocks found under 'Control' or similar category:\n    *   `Setup`: Blocks placed here run ONCE when the board powers on or resets. Used for initial configuration (e.g., setting pin modes).\n    *   `Loop`: Blocks placed here run REPEATEDLY, forever, after the Setup block finishes. This is where the main logic of your program goes.\n\n## Common Block Categories & Examples\n\n*   **Pins (Digital):**\n    *   `Set Digital Pin [pin#] as [OUTPUT/INPUT/INPUT_PULLUP]`: (Goes in Setup) Configures a pin.\n    *   `Set Digital Pin [pin#] to [HIGH/LOW]`: (Goes in Loop) Turns an output pin ON (HIGH/5V) or OFF (LOW/0V).\n    *   `Read Digital Pin [pin#]`: (Goes in Loop) Returns the state (HIGH/1 or LOW/0) of an input pin.\n*   **Pins (Analog/PWM):**\n    *   `Analog Write (PWM) Pin [~pin#] to [value]`: (Goes in Loop) Outputs a PWM signal (0-255) on PWM pins (~3, ~5, ~6, ~9, ~10, ~11) for fading LEDs or controlling motor speed.\n    *   `Read Analog Pin [A0-A5]`: (Goes in Loop) Reads voltage on an analog pin (0-1023 representing 0-5V).\n*   **Control:**\n    *   `Wait [1000] ms`: Pauses the program for the specified milliseconds (1000ms = 1 second).\n    *   `Repeat [10] times { ... }`: Executes blocks inside the loop a fixed number of times.\n    *   `Forever { ... }`: (This is the main Loop structure block)\n    *   `If <condition> then { ... } else { ... }`: Executes blocks based on a condition.\n    *   `Break out of Loop`: Exits the current loop.\n*   **Logic:**\n    *   `<value> [= / != / < / > / <= / >=] <value>`: Comparison blocks used in If conditions.\n    *   `<condition> [AND / OR] <condition>`: Combine multiple conditions.\n    *   `NOT <condition>`: Invert a condition.\n    *   `[True / False]` Boolean constants.\n*   **Math:**\n    *   `[number] [+ / - / * / / / %] [number]`: Basic arithmetic.\n    *   `Random Integer from [1] to [100]`\n    *   `Map [value] from low [0] high [1023] to low [0] high [255]`: Re-scales a number from one range to another (useful for sensor readings -> PWM output).\n*   **Variables:**\n    *   `Create Variable [variable_name]`: Declare a variable to store data.\n    *   `Set [variable_name] to [value]`: Assign a value to a variable.\n    *   `Change [variable_name] by [1]`: Modify a variable's value.\n*   **Communication (Serial):**\n    *   `Serial Begin [9600]`: (Goes in Setup) Initializes serial communication at specified baud rate.\n    *   `Serial Print [text or value]`: Sends data to Serial Monitor.\n    *   `Serial Print Line [text or value]`: Sends data followed by a newline.\n\n## Uploading Code\n\n1.  Connect KinetiCore Uno board via USB.\n2.  Select correct Board and Port under Tools menu.\n3.  Assemble your block program in the workspace within Setup and Loop blocks.\n4.  Click the Upload button.\n5.  Wait for compilation and upload process to complete (messages shown in output area).\n\nBuild the circuits from the EPB and implement the corresponding block code!"}
{"_id": "LL-MCU-001_FAQ_v1.0", "product_id": "LL-MCU-001", "product_name": "MicroController Starter Kit (KinetiCore Uno)", "doc_type": "Troubleshooting FAQ", "version": "1.0", "title": "MicroController Starter Kit Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# MicroController Starter Kit Troubleshooting FAQ (v1.0)\n\nSolving common microcontroller and circuit issues.\n\n## Board & Connection Issues\n\n*   **Board Not Detected by Computer / Port Not Showing in IDE:**\n    *   Check USB cable connection at both ends.\n    *   Try a different USB port on the computer.\n    *   Try a different USB cable (ensure it's a data cable, not power-only).\n    *   Install/reinstall necessary drivers (CH340/FTDI - check which chip your board uses).\n    *   Restart computer and IDE.\n    *   Ensure board is selected correctly under Tools > Board menu.\n*   **Code Upload Fails (Errors during upload):**\n    *   **Port Not Selected / Incorrect Port:** Verify correct COM/tty port is selected under Tools > Port.\n    *   **Board Busy / Port Access Denied:** Another program (like Serial Monitor, or another IDE instance) might be using the port. Close other programs and try again.\n    *   **Incorrect Board Selected:** Ensure Tools > Board matches \"KinetiCore Uno\" or \"Arduino Uno\".\n    *   **Hardware Issue:** Less common - faulty USB cable, board issue.\n    *   **Bootloader Issue:** Rare - may require re-burning bootloader (advanced).\n*   **Board Power Light (ON) Not Lit:**\n    *   Check USB connection providing power.\n    *   If using external power jack, check adapter connection and voltage/polarity.\n    *   Possible board hardware failure.\n\n## Circuit & Component Issues\n\n*   **LED Not Lighting Up:**\n    *   **Code Issue:** Is the code correctly setting the pin HIGH? Is the pin configured as OUTPUT in Setup?\n    *   **Wiring Issue:** Check all connections: Pin -> Resistor -> LED Anode (long leg) -> LED Cathode (short leg) -> GND.\n    *   **LED Orientation:** Is the LED inserted backwards? Long leg must connect towards positive/pin side.\n    *   **Resistor Value:** Is resistor correct value (e.g., 220Ω-1kΩ)? Too high a value makes LED dim; no resistor burns out LED.\n    *   **Faulty LED/Resistor/Wire:** Try swapping components.\n    *   **Incorrect Pin:** Is LED connected to the pin specified in the code?\n*   **Button Not Detected / Reading Always HIGH or LOW:**\n    *   **Wiring Issue:** Check button wiring, especially the pull-down or pull-up resistor setup (refer to EPB Exp 2). Missing or incorrect resistor causes floating input.\n    *   **Code Issue:** Is the pin configured as INPUT (or INPUT_PULLUP if using internal pull-up)? Is code reading the correct pin? Is logic correct (e.g., checking for HIGH when using pull-down)?\n    *   **Faulty Button/Resistor/Wire.**\n*   **Analog Sensor Reading Incorrect / Always 0 or 1023:**\n    *   **Wiring Issue:** Check voltage divider wiring (Power->Sensor->AnalogPin->Resistor->GND). Ensure Analog Pin connection is at the junction.\n    *   **Code Issue:** Is code reading the correct Analog Pin (A0-A5)?\n    *   **Power/Ground Missing:** Ensure sensor circuit has 5V and GND connections.\n    *   **Faulty Sensor.**\n*   **Serial Monitor Shows Gibberish / No Data:**\n    *   **Baud Rate Mismatch:** Ensure baud rate set in `Serial Begin` block (e.g., 9600) MATCHES the baud rate selected in the Serial Monitor window.\n    *   **Serial Begin Missing:** Did you include `Serial Begin` in Setup block?\n    *   **Wiring Issue (if using external serial device):** TX/RX connections.\n\n## General Tips\n\n*   **Check Connections:** Loose wires are a common problem.\n*   **Simplify:** If a complex circuit fails, test individual parts (blink an LED, read a button) separately.\n*   **Comment Code (if applicable):** Add notes to explain block sections.\n*   **Use Serial Monitor:** Print variable values or status messages to understand what your code is doing.\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with model (LL-MCU-001), IDE version, OS, code (screenshot/export), circuit diagram/photo, and problem description."}
{"_id": "LL-MCU-001_SI_v1.0", "product_id": "LL-MCU-001", "product_name": "MicroController Starter Kit (KinetiCore Uno)", "doc_type": "Safety Information", "version": "1.0", "title": "MicroController Starter Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# MicroController Starter Kit Safety Information (v1.0)\n\nWorking safely with microcontrollers and circuits.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (LEDs, resistors, wires, buttons). Not for children under 3 years.**\n*   **Recommended Age:** 10+ Adult supervision recommended, especially when first learning about circuits.\n*   **Electrical Safety:** Operates at safe, low DC voltage (5V/3.3V) from USB or appropriate external adapter.\n    *   Use only the specified power sources (USB or compatible wall adapter - check voltage/polarity/current limits).\n    *   Avoid short circuits: Do not directly connect 5V/3.3V pins to GND pins. Do not connect output pins directly together if one is HIGH and one is LOW.\n    *   Handle board by edges; avoid touching pins when powered, although voltage is low.\n    *   Static Discharge (ESD): Ground yourself before handling the KinetiCore Uno board or sensitive components, especially in dry environments.\n    *   Do not expose board or components to water/liquids.\n*   **Component Handling:**\n    *   LEDs have polarity (long leg = positive/anode). Inserting backwards prevents them from working. Connecting without a current-limiting resistor will burn them out.\n    *   Handle components carefully; leads can bend or break.\n*   **Breadboard Use:** Insert component leads and jumper wires gently but firmly into breadboard holes. Do not force oversized leads. Ensure wires make good contact.\n*   **Computer Safety:** Connecting hardware via USB carries a small risk to the computer port if severe short circuits occur on the board. Follow wiring diagrams carefully.\n\nThis kit is designed for educational purposes. Follow instructions and standard electronics safety practices."}
{"_id": "LL-MCU-002_UG_v1.0", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "User Guide", "version": "1.0", "title": "IoT Explorer Kit (KinetiCore ESP) User Guide", "language": "en-US", "format": "Markdown", "text": "# IoT Explorer Kit (KinetiCore ESP) User Guide (v1.0)\n\nConnecting your projects to the Internet!\n\n## Kit Contents Overview\n\n*   KinetiCore ESP Microcontroller Board (ESP32-based, with Wi-Fi & Bluetooth)\n*   USB Cable (Type A to Micro-USB or Type C - check board)\n*   Breadboard\n*   Jumper Wires\n*   Basic Components (LEDs, Resistors, Buttons)\n*   Sensors suitable for IoT (e.g., Temp/Humidity Sensor - DHT11/22, Light Sensor)\n*   (Maybe: Small OLED Display, Relay Module)\n*   Software Info Card (for IDEs like Thonny + MicroPython or Kinetic Blocks)\n\n*(Illustrations: KinetiCore ESP board layout with pin labels, Breadboard)*\n\n## Understanding the KinetiCore ESP Board\n\n*   **Microcontroller:** ESP32 chip - powerful processor with built-in Wi-Fi and Bluetooth.\n*   **Connectivity:** Wi-Fi (2.4GHz), Bluetooth (Classic & BLE).\n*   **USB Port:** For programming, power, and serial communication.\n*   **Pins:** Digital I/O, Analog Inputs (ADC), PWM, I2C, SPI interfaces. Pin mapping differs from Arduino Uno - **refer to board pinout diagram!**\n*   **Voltage:** Typically operates at 3.3V logic levels (IMPORTANT: Connecting 5V signals directly to pins can damage the board!). May have 5V input pin (VIN) and onboard 3.3V regulator.\n*   **Buttons:** Usually Reset and Boot/Flash buttons.\n*   **LEDs:** Power, user-controllable LED (often on GPIO2).\n\n## Software Setup Options\n\n*   **Option 1: Kinetic Blocks IDE (Block-Based):**\n    1.  Install Kinetic Blocks IDE.\n    2.  May require installing ESP32 board support package within the IDE (check Tools > Board Manager).\n    3.  Connect board via USB. Install drivers if needed (often CP210x or CH340).\n    4.  Select correct KinetiCore ESP board and Port in Tools menu.\n*   **Option 2: MicroPython (Text-Based):**\n    1.  **Flash MicroPython Firmware:** Requires downloading MicroPython firmware (.bin file) for ESP32 and using a flashing tool (like `esptool.py`) to upload it to the board initially. (See MicroPython documentation for details - this is a one-time setup).\n    2.  **Install IDE:** Use an IDE like Thonny (recommended for beginners).\n    3.  **Configure Thonny:** Select MicroPython (ESP32) as the interpreter and choose the correct Serial Port for the board.\n    4.  You can now write and run MicroPython scripts directly on the board via Thonny's interface.\n\n## First Program (MicroPython Example using Thonny)\n\n1.  Connect KinetiCore ESP board (with MicroPython firmware flashed) to PC.\n2.  Open Thonny, select MicroPython(ESP32) interpreter and correct port.\n3.  In the Thonny editor window, type:\n    ```python\n    import machine\n    import time\n    \n    led = machine.Pin(2, machine.Pin.OUT) # Pin 2 is often the built-in LED\n    \n    while True:\n        led.on()\n        time.sleep(0.5)\n        led.off()\n        time.sleep(0.5)\n    ```\n4.  Click the 'Run current script' button (Green Play icon) in Thonny.\n5.  The script is sent to the board and runs. The built-in LED (usually on Pin 2) should start blinking.\n6.  Click 'Stop' button (Red Stop icon) to halt the script.\n\nRefer to EPB, BCG (if using Blocks), or API (MicroPython) docs for circuit building and specific coding examples (Wi-Fi, Bluetooth, sensors)."}
{"_id": "LL-MCU-002_EPB_v1.1", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "Experiment & Project Book", "version": "1.1", "title": "IoT Explorer Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# IoT Explorer Experiment & Project Book (v1.1)\n\nConnecting the physical world to the digital world.\n\n## Introduction to IoT & KinetiCore ESP\n\n*   **Internet of Things (IoT):** Connecting everyday objects (with sensors/actuators) to the internet to collect data or be controlled remotely.\n*   **KinetiCore ESP (ESP32-based):** Ideal for IoT due to built-in Wi-Fi and Bluetooth, low power consumption, and processing power.\n*   **Programming:** Use Kinetic Blocks IDE or MicroPython (text-based Python for microcontrollers).\n*   **3.3V Logic:** Remember ESP32 pins use 3.3V logic levels. Use level shifting if interfacing with 5V components directly on input pins.\n\n## Experiment 1: Wi-Fi Network Scan\n\n*   **Goal:** Scan for available Wi-Fi networks nearby.\n*   **Circuit:** KinetiCore ESP board connected to PC via USB.\n*   **Code (MicroPython Example):**\n    ```python\n    import network\n    import time\n    \n    wlan = network.WLAN(network.STA_IF) # Station interface\n    wlan.active(True)\n    \n    print('Scanning for networks...')\n    networks = wlan.scan()\n    \n    if not networks:\n        print('No networks found.')\n    else:\n        print('Networks found:')\n        for ssid, bssid, channel, RSSI, authmode, hidden in networks:\n            print(f'  SSID: {ssid.decode(\"utf-8\")}, Channel: {channel}, RSSI: {RSSI}')\n            \n    wlan.active(False) # Turn off Wi-Fi\n    ```\n*   **Run & Observe:** Run the script (using Thonny). Output in the REPL/Shell window lists nearby Wi-Fi network names (SSIDs), channel, and signal strength (RSSI).\n\n## Experiment 2: Connect to Wi-Fi & Get Time from Internet\n\n*   **Goal:** Connect the board to your local Wi-Fi and fetch current time from an NTP server.\n*   **Circuit:** KinetiCore ESP connected via USB.\n*   **Code (MicroPython Example):**\n    ```python\n    import network\n    import time\n    import ntptime\n    \n    ssid = 'YOUR_WIFI_SSID' # Replace with your network name\n    password = 'YOUR_WIFI_PASSWORD' # Replace with your password\n    \n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    \n    if not wlan.isconnected():\n        print('Connecting to network...')\n        wlan.connect(ssid, password)\n        while not wlan.isconnected():\n            time.sleep(1)\n    print('Network config:', wlan.ifconfig())\n    \n    try:\n        print(\"Synchronizing time...\")\n        ntptime.settime() # Synchronize with NTP server\n        current_time = time.localtime() # Get tuple (year, month, day, hour, min, sec...)\n        print(f\"Current Time: {current_time[3]:02d}:{current_time[4]:02d}:{current_time[5]:02d}\")\n    except Exception as e:\n        print(f\"Error getting time: {e}\")\n    \n    wlan.active(False)\n    ```\n*   **Run & Observe:** Replace placeholders with your Wi-Fi credentials. Run script. Board connects to Wi-Fi and prints current time (UTC by default).\n\n## Experiment 3: Read Sensor Data (e.g., DHT11 Temp/Humidity)\n\n*   **Goal:** Read temperature and humidity from a DHT sensor.\n*   **Circuit:** Connect DHT11/22 sensor: VCC to 3.3V pin, GND to GND pin, Data pin to a GPIO pin (e.g., GPIO 4) on KinetiCore ESP. (May need pull-up resistor on Data line - check sensor datasheet).\n    *(Diagram of DHT sensor connection)*\n*   **Code (MicroPython Example - requires `dht` library pre-loaded or installed):**\n    ```python\n    import machine\n    import dht\n    import time\n    \n    d = dht.DHT11(machine.Pin(4)) # Or DHT22; Use correct GPIO pin\n    \n    while True:\n        try:\n            d.measure() # Trigger measurement\n            temp_c = d.temperature()\n            humidity = d.humidity()\n            print(f'Temperature: {temp_c}°C, Humidity: {humidity}%')\n        except OSError as e:\n            print('Failed to read sensor.')\n            \n        time.sleep(2) # DHT sensors need >1 sec between readings\n    ```\n*   **Run & Observe:** Run script. See temperature/humidity printed.\n\n## Experiment 4: Control LED via Web Server (Simple)\n\n*   **Goal:** Turn an LED connected to the board ON/OFF by visiting web addresses from a browser on the same Wi-Fi network.\n*   **Circuit:** Connect LED (with resistor) to a GPIO pin (e.g., GPIO 5).\n*   **Code:** (Involves setting up Wi-Fi connection, importing `socket`, creating a simple web server that listens for requests like `'/ledon'` or `'/ledoff'`, and controlling the GPIO pin accordingly. Code is more complex - see MicroPython socket/web server examples).\n*   **Run & Observe:** Run script. Get board's IP address. From a browser on same network, go to `http://<board_ip>/ledon` or `http://<board_ip>/ledoff`. Observe LED.\n\n## Project Ideas\n\n*   **Web-Based Weather Display:** Combine Exp 2 & 3. Read sensors, host web page on ESP32 showing current readings.\n*   **MQTT Sensor Node:** Read sensor data, publish it to an MQTT broker (cloud service) for remote monitoring.\n*   **Bluetooth Controlled Robot:** Use Bluetooth connection to control motors/servos from a custom phone app.\n*   **Smart Plant Monitor:** Read soil moisture sensor, publish data, potentially control a small water pump (via relay).\n\nExplore the vast possibilities of connected devices!"}
{"_id": "LL-MCU-002_BCG_v1.0", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "Block Coding Guide", "version": "1.0", "title": "Kinetic Blocks IDE Block Coding Guide (for ESP)", "language": "en-US", "format": "Markdown", "text": "# Kinetic Blocks IDE Block Coding Guide (for ESP) (v1.0)\n\nBlock coding for your connected KinetiCore ESP projects.\n\n## IDE Setup for ESP32\n\n1.  Ensure KinetiCore ESP board is connected via USB.\n2.  In Kinetic Blocks IDE, go to Tools > Board and select the specific KinetiCore ESP board model.\n3.  Go to Tools > Port and select the correct COM/tty port.\n4.  (One time) You might need to install ESP32 support via Tools > Board Manager if not built-in.\n\n## New Block Categories for IoT\n\n*(Screenshot: IDE showing Wi-Fi, Bluetooth, Web Server, MQTT block categories)*\n\n*   **Wi-Fi:**\n    *   `Setup Wi-Fi Connect SSID [ssid] Password [password]`: (Goes in Setup) Connects to your Wi-Fi.\n    *   `Is Wi-Fi Connected?`: Returns True/False.\n    *   `Get IP Address`: Returns the board's IP address.\n*   **Bluetooth:** (Blocks depend on Classic vs BLE support)\n    *   `Setup Bluetooth Serial [Device Name]`\n    *   `Bluetooth Serial Available?` / `Read Bluetooth Serial`\n    *   `Bluetooth Serial Print [data]`\n*   **Web Server (Simple):**\n    *   `Setup Web Server on Port [80]`: Starts the server.\n    *   `When Web Server receives request [path] do { ... }`: Event block triggered by browser requests (e.g., path = \"/ledon\").\n    *   `Web Server Send Response [HTML content]`: Sends data back to browser.\n*   **Network / Internet:**\n    *   `HTTP GET Request URL [url]` : Fetch data from a web address.\n    *   `Get NTP Time`: Synchronize internal clock.\n*   **MQTT (If supported):**\n    *   `Connect to MQTT Broker [address] Port [port] ...`\n    *   `Publish to MQTT Topic [topic] Message [message]`\n    *   `Subscribe to MQTT Topic [topic]`\n    *   `When MQTT Message Received on Topic [topic] { ... }`: Event block.\n*   **Sensors (Specific):**\n    *   Blocks for specific sensors like `Read DHT11/22 Temperature on Pin [pin#]` / `Humidity`. Requires installing corresponding library in IDE (Tools > Manage Libraries).\n\n## Example Project 1: Wi-Fi Connection Status LED\n\n```markdown\n// Setup Block\nSetup Wi-Fi Connect SSID \"YOUR_SSID\" Password \"YOUR_PASSWORD\"\nSet Digital Pin [2] as OUTPUT // Built-in LED\n\n// Loop Block\nForever {\n  If Is Wi-Fi Connected? then {\n    Set Digital Pin [2] to LOW // LED ON (assuming active low)\n  } else {\n    Set Digital Pin [2] to HIGH // LED OFF\n  }\n  Wait [500] ms\n  Set Digital Pin [2] to HIGH // Blink if not connected\n  Wait [500] ms\n}\n```\n*Description: Attempts to connect to Wi-Fi. Built-in LED stays ON if connected, blinks if not connected.* \n\n## Example Project 2: Read Sensor and Print to Serial Monitor\n\n```markdown\n// Setup Block\nSerial Begin [115200] // ESP32 often uses higher default baud rate\n// (DHT library setup/include block might be needed here)\n\n// Loop Block\nForever {\n  Temp = Read DHT11 Temperature on Pin [4]\n  Humid = Read DHT11 Humidity on Pin [4]\n  Serial Print \"Temp: \"\n  Serial Print Temp\n  Serial Print \" C, Humid: \"\n  Serial Print Humid\n  Serial Print Line \"%\"\n  Wait [2000] ms // Wait 2 seconds between readings\n}\n```\n*Description: Reads temperature and humidity from a DHT11 sensor on Pin 4 and prints the values to the Serial Monitor every 2 seconds.* \n\n## Uploading Code\n\n*   Same process as for Uno: Assemble blocks, select Board/Port, click Upload.\n*   ESP32 uploads can sometimes be slower than Uno.\n*   You might need to hold the BOOT/FLASH button on the board while clicking Upload if it fails to enter programming mode automatically.\n\nUse these blocks to build connected projects from the EPB!"}
{"_id": "LL-MCU-002_API_v1.0", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "MicroPython API Reference", "version": "1.0", "title": "KinetiCore ESP MicroPython API Reference", "language": "en-US", "format": "Markdown", "text": "# KinetiCore ESP MicroPython API Reference (v1.0)\n\nCore MicroPython modules for ESP32-based boards.\n\n**(Note: This summarizes standard MicroPython modules often used with ESP32. Specific board variations might have minor differences or extra libraries pre-installed.)**\n\n## `machine` Module: Hardware Control\n\n*   **Pins:**\n    *   `pin = machine.Pin(pin_num, mode, pull=None, value=None)`: Create Pin object.\n        *   `pin_num`: GPIO number (refer to board pinout).\n        *   `mode`: `machine.Pin.IN`, `machine.Pin.OUT`, `machine.Pin.OPEN_DRAIN`.\n        *   `pull`: `machine.Pin.PULL_UP`, `machine.Pin.PULL_DOWN`, `None`.\n    *   `pin.value([val])`: Get/Set pin state (0=LOW, 1=HIGH).\n    *   `pin.on()`: Set pin HIGH.\n    *   `pin.off()`: Set pin LOW.\n*   **PWM (Pulse Width Modulation):**\n    *   `pwm = machine.PWM(pin, freq=5000, duty=512)`: Create PWM object.\n        *   `pin`: Pin object (must support PWM).\n        *   `freq`: Frequency in Hz.\n        *   `duty`: 0-1023 (0% to 100% duty cycle).\n    *   `pwm.freq([freq_val])`: Get/Set frequency.\n    *   `pwm.duty([duty_val])`: Get/Set duty cycle (0-1023).\n    *   `pwm.deinit()`: Turn off PWM.\n*   **ADC (Analog to Digital Converter):**\n    *   `adc = machine.ADC(pin)`: Create ADC object.\n        *   `pin`: Pin object (must support ADC).\n    *   `adc.read()`: Read analog value (typically 0-4095 for ESP32 12-bit ADC).\n    *   `adc.atten(atten_val)`: Set attenuation (e.g., `machine.ADC.ATTN_11DB` for 0-3.3V range).\n*   **Other:** `machine.I2C`, `machine.SPI`, `machine.UART`, `machine.Timer`, `machine.reset()`, `machine.sleep()`.\n\n## `network` Module: Wi-Fi Connectivity\n\n*   `wlan_sta = network.WLAN(network.STA_IF)`: Get Station interface (connect TO an Access Point).\n*   `wlan_ap = network.WLAN(network.AP_IF)`: Get Access Point interface (create OWN network).\n*   `wlan.active(True/False)`: Activate/Deactivate interface.\n*   `wlan_sta.scan()`: Scan for networks -> list of tuples.\n*   `wlan_sta.connect(ssid, password)`: Connect to network.\n*   `wlan_sta.isconnected()`: Check connection status -> bool.\n*   `wlan_sta.ifconfig()`: Get IP configuration -> tuple (ip, subnet, gateway, dns).\n*   `wlan_ap.config(ssid='MyESP_AP', password='mypassword')`: Configure Access Point.\n\n## `time` Module: Time & Delays\n\n*   `time.sleep(seconds)`: Pause for float seconds.\n*   `time.sleep_ms(milliseconds)`: Pause for integer milliseconds.\n*   `time.sleep_us(microseconds)`: Pause for integer microseconds.\n*   `time.ticks_ms()`, `time.ticks_us()`, `time.ticks_cpu()`: Get uptime counters (handle wraparound with `time.ticks_diff()`).\n*   `time.localtime([secs])`: Convert seconds since Epoch to time tuple.\n*   `time.mktime(tuple)`: Convert time tuple back to seconds since Epoch.\n\n## `ntptime` Module: Network Time Protocol\n\n*   `ntptime.settime()`: Synchronize board's real-time clock with internet NTP server (requires active Wi-Fi connection).\n\n## `socket` Module: Network Communication\n\n*   Standard MicroPython socket implementation for TCP/IP and UDP communication.\n*   `socket.socket(family, type)`\n*   `sock.bind((host, port))`\n*   `sock.listen(backlog)`\n*   `conn, addr = sock.accept()`\n*   `sock.connect((host, port))`\n*   `sock.send(bytes)`\n*   `sock.recv(bufsize)` -> bytes\n*   `sock.close()`\n\n## `urequests` Module (Commonly Added Library): HTTP Requests\n\n*   `import urequests`\n*   `response = urequests.get(url)`\n*   `response = urequests.post(url, data=payload / json=payload)`\n*   `response.status_code`\n*   `response.text`\n*   `response.json()`\n\n## `umqtt.simple` Module (Commonly Added Library): MQTT Client\n\n*   `from umqtt.simple import MQTTClient`\n*   `client = MQTTClient(client_id, server, port, user, password)`\n*   `client.connect()`\n*   `client.set_callback(callback_function)`\n*   `client.subscribe(topic)`\n*   `client.publish(topic, message)`\n*   `client.wait_msg()` / `client.check_msg()` (For handling incoming messages)\n*   `client.disconnect()`\n\n## Sensor Libraries (Examples - Need Installation)\n\n*   **DHT Sensor:** `import dht; d = dht.DHT11(pin); d.measure(); temp=d.temperature()`\n*   **OLED Display (SSD1306):** `import ssd1306; display=ssd1306.SSD1306_I2C(width, height, i2c); display.text(...); display.show()`\n\n**Refer to official MicroPython documentation (docs.micropython.org) and specific library documentation for complete details and more modules.**"}
{"_id": "LL-MCU-002_FAQ_v1.0", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "Troubleshooting FAQ", "version": "1.0", "title": "IoT Explorer Kit Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# IoT Explorer Kit Troubleshooting FAQ (v1.0)\n\nDebugging your connected ESP32 projects.\n\n## Board & Connection Issues\n\n*   **(Board Not Detected / Port Issues / Upload Failures):** Refer to LL-MCU-001_FAQ_v1.0. Specific drivers for ESP32 boards are often CP210x or CH340. You might need to **hold the BOOT/FLASH button** on the board while initiating the upload/flash process if it doesn't enter programming mode automatically.\n*   **Brownout Detected / Board Resetting Continuously:**\n    *   **Insufficient Power:** ESP32 Wi-Fi/Bluetooth radios draw significant current. Powering complex circuits + Wi-Fi from a basic computer USB port might be insufficient. Try a powered USB hub or a dedicated 5V power supply connected to VIN/5V pin (ensure correct voltage!).\n    *   **Short Circuit:** Check breadboard wiring for accidental shorts.\n*   **MicroPython: Failed to Flash Firmware:**\n    *   Ensure correct firmware file (.bin) for your specific ESP32 board variant.\n    *   Verify flashing tool (`esptool.py`) command syntax is correct (port, baud rate, file path).\n    *   Hold BOOT button while powering on/resetting board to enter flashing mode.\n*   **MicroPython: Cannot Connect via Thonny/REPL:**\n    *   Ensure correct port selected in Thonny.\n    *   Firmware might be corrupted - try re-flashing.\n    *   Board might be stuck in a script loop - try interrupting (Ctrl+C in Thonny Shell) or Safe Boot (specific button press on startup - check board docs).\n\n## Wi-Fi & Network Issues\n\n*   **Cannot Connect to Wi-Fi:**\n    *   Double-check SSID and Password in your code (case-sensitive!).\n    *   Ensure board is within range of the Wi-Fi router.\n    *   Verify router is using 2.4GHz band (ESP32 usually doesn't support 5GHz).\n    *   Check router security settings (WPA2-PSK typically compatible).\n    *   Network might be congested or router blocking new devices.\n*   **Network Requests Failing (HTTP, MQTT, NTP):**\n    *   Verify board has successfully connected to Wi-Fi and obtained an IP address.\n    *   Check if the target server/URL is correct and reachable from your network.\n    *   Check firewall settings on your network (might block outgoing connections on specific ports).\n    *   DNS Issue: `wlan.ifconfig()` should show a DNS server address.\n*   **Web Server Not Accessible from Browser:**\n    *   Ensure board is connected to the SAME Wi-Fi network as the device running the browser.\n    *   Verify the IP address being used in the browser matches the board's current IP.\n    *   Check if web server code is running correctly on the board without errors.\n\n## Bluetooth Issues\n\n*   **Cannot Pair / Connect:**\n    *   Ensure Bluetooth code (e.g., BLE advertising or Bluetooth Serial setup) is running on the ESP32.\n    *   Ensure Bluetooth is enabled on the connecting device (phone/PC).\n    *   Check range.\n    *   Try clearing Bluetooth cache on phone/PC.\n*   **Data Transfer Errors:** Check code logic for sending/receiving data. Ensure matching protocols/services.\n\n## Sensor & Peripheral Issues\n\n*   **(General Circuit Issues - LED, Button):** Refer to LL-MCU-001_FAQ_v1.0, but remember ESP32 uses **3.3V logic levels**. Use voltage dividers or level shifters when interfacing 5V sensor outputs to ESP32 input pins.\n*   **Specific Sensor Not Working (DHT, etc.):**\n    *   **Check Wiring:** VCC to 3.3V pin (NOT 5V unless sensor is 5V tolerant AND has onboard regulator), GND to GND, Data to correct GPIO pin.\n    *   **Check Code:** Using correct GPIO pin number in code? Imported necessary library (e.g., `import dht`)?\n    *   **Library Missing/Incorrect (MicroPython):** Ensure required sensor library (.py file) is uploaded to the board's filesystem (using Thonny's File > Save As > MicroPython Device).\n    *   **Pull-up Resistor:** Some sensors (like DHT, I2C devices) require pull-up resistors on data lines.\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with model (LL-MCU-002), IDE/Firmware version, code, circuit diagram, and problem description."}
{"_id": "LL-MCU-002_SI_v1.0", "product_id": "LL-MCU-002", "product_name": "IoT Explorer Kit (KinetiCore ESP)", "doc_type": "Safety Information", "version": "1.0", "title": "IoT Explorer Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# IoT Explorer Kit Safety Information (v1.0)\n\nSafe practices for connected microcontroller projects.\n\n*   **WARNING: CHOKING HAZARD -- Small parts. Not for children under 3 years.**\n*   **Recommended Age:** 12+ Requires understanding of electronics, coding, and basic network concepts. Adult supervision recommended.\n*   **Electrical Safety:** Operates at safe, low DC voltage (primarily 3.3V logic, powered via 5V USB).\n    *   Use only the specified power sources (USB or compatible 5V supply to VIN).\n    *   **3.3V Logic Levels:** Be aware that ESP32 GPIO pins operate at 3.3V. Connecting components that output 5V directly to ESP32 input pins can damage the board. Use level shifters or voltage dividers where necessary.\n    *   Avoid short circuits.\n    *   Handle board carefully, avoid static discharge (ESD).\n    *   Do not expose to water/liquids.\n*   **Wi-Fi / Bluetooth (RF Exposure):** Contains radio transmitters. Maintain separation distance (>20cm recommended) during operation where possible.\n*   **Network Security:** Connecting devices to the internet carries inherent risks.\n    *   Use strong, unique passwords for your Wi-Fi network.\n    *   Be cautious when connecting to public Wi-Fi networks.\n    *   When using cloud services (e.g., MQTT brokers, web dashboards), use secure authentication methods and be mindful of data privacy.\n    *   Keep firmware and libraries updated for security patches.\n*   **Component Handling:** Follow standard electronics component handling practices.\n*   **Relay Module Usage (If Included):** If using relays to control AC mains voltage devices, this requires advanced knowledge and EXTREME CAUTION. This should only be done by experienced users following all electrical safety codes. **Beginners should NOT connect kit components directly to AC mains power.**\n\nThis kit is for educational purposes. Follow instructions and safety practices."}
{"_id": "LL-MCU-003_UG_v1.0", "product_id": "LL-MCU-003", "product_name": "Compute Hub Kit (KinetiCore Pi)", "doc_type": "User Guide", "version": "1.0", "title": "Compute Hub Kit (KinetiCore Pi) User Guide", "language": "en-US", "format": "Markdown", "text": "# Compute Hub Kit (KinetiCore Pi) User Guide (v1.0)\n\nSetting up your Raspberry Pi-based learning computer.\n\n## Kit Contents Overview\n\n*   KinetiCore Pi Board (Raspberry Pi variant, e.g., Pi 4 Model B or Pi Zero 2 W)\n*   Protective Case for Pi Board\n*   MicroSD Card (Pre-loaded with Raspberry Pi OS + Kinetic Learning Environment)\n*   Power Supply (USB-C or Micro USB, appropriate wattage)\n*   Micro HDMI to HDMI Cable (or Adapter, depending on Pi model)\n*   USB Keyboard\n*   USB Mouse\n*   (Optional: Heatsink set for Pi board)\n*   (Optional: Breadboard & Basic Electronic Components similar to LL-MCU-001 for GPIO projects)\n\n*(Illustrations: Pi board layout, Case assembly, Connection diagram)*\n\n## Assembling the Compute Hub\n\n1.  **(Optional) Apply Heatsinks:** If included, peel backing and apply heatsinks to the main processor and potentially other chips on the Pi board.\n2.  **Insert Pi into Case:** Carefully place the KinetiCore Pi board into the protective case, aligning ports with openings. Secure the case (snaps or screws).\n3.  **Insert MicroSD Card:** Insert the pre-loaded MicroSD card into the card slot on the Pi board (usually underside).\n\n## Connecting Peripherals\n\n*(Diagram: Shows Pi in case connected to Power, HDMI Monitor, Keyboard, Mouse)*\n\n1.  **Display:** Connect the Micro HDMI cable end to the Pi board's HDMI port(s). Connect the standard HDMI end to a computer monitor or TV.\n2.  **Keyboard & Mouse:** Plug the USB Keyboard and USB Mouse into the USB ports on the Pi board.\n3.  **Network (Optional):**\n    *   **Ethernet:** Plug network cable into Ethernet port (if available on Pi model).\n    *   **Wi-Fi:** Will be configured within the operating system later.\n4.  **Power (Connect LAST):** Plug the Power Supply into the wall and connect the USB-C / Micro USB end to the Pi's designated power input port.\n\n## First Boot & Initial Setup\n\n1.  **Power On:** The Pi should boot automatically when power is connected. You'll see boot sequences on the connected display.\n2.  **Raspberry Pi OS Desktop:** It should boot into the Raspberry Pi OS graphical desktop environment.\n3.  **Initial Configuration Wizard:** On first boot, a wizard usually runs prompting you to:\n    *   Set Country/Language/Timezone.\n    *   Change the default password (IMPORTANT! Default user is 'pi', password 'raspberry').\n    *   Connect to your Wi-Fi network (select SSID, enter password).\n    *   Check for software updates (allow it to update).\n    *   Restart when prompted.\n\n## Kinetic Learning Environment\n\n*   The pre-loaded OS likely includes:\n    *   **Thonny IDE:** For writing and running Python code.\n    *   **Scratch:** Block-based coding environment.\n    *   **GPIO Libraries:** For controlling electronic components connected to the Pi's GPIO pins.\n    *   **Kinetic Guides/Tutorials:** Custom learning resources accessible from the desktop or menu.\n    *   Standard Linux utilities and applications (Web Browser, Text Editor, Terminal).\n\n## Accessing GPIO Pins\n\n*   The Pi board has a row of General Purpose Input/Output (GPIO) pins.\n*   These allow connecting electronic components (LEDs, buttons, sensors) for programming interaction.\n*   **Pinout is CRITICAL:** Refer to the specific KinetiCore Pi model pinout diagram. Pins provide 3.3V, 5V, GND, and controllable I/O.\n*   **3.3V Logic:** Raspberry Pi GPIO pins use 3.3V logic levels.\n\nRefer to the Experiment & Project Book (EPB) and Software Guide (SWG) for programming and electronics projects."}
{"_id": "LL-MCU-003_EPB_v1.0", "product_id": "LL-MCU-003", "product_name": "Compute Hub Kit (KinetiCore Pi)", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Compute Hub Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Compute Hub Experiment & Project Book (v1.0)\n\nExploring Computing, Linux, Python, and Electronics with KinetiCore Pi.\n\n## Introduction\n\n*   **KinetiCore Pi (Raspberry Pi):** A small, capable single-board computer running a Linux-based operating system (Raspberry Pi OS).\n*   **Capabilities:** Desktop computing, web browsing, programming (Python, Scratch, etc.), controlling electronics via GPIO pins.\n*   **Learning Goals:** Understand computer basics, navigate Linux, write Python code, interface with hardware.\n\n## Module 1: Navigating Raspberry Pi OS\n\n*   **Experiment 1.1: Desktop Tour:** Explore the desktop, main menu (Raspberry icon), taskbar, file manager, terminal icon.\n*   **Experiment 1.2: Using the Terminal:** Open the Terminal. Learn basic Linux commands:\n    *   `ls`: List files/directories.\n    *   `cd <directory>`: Change directory.\n    *   `pwd`: Print working directory.\n    *   `mkdir <name>`: Make directory.\n    *   `sudo apt update && sudo apt upgrade`: Update system software (requires internet, password).\n*   **Experiment 1.3: Web Browser & Text Editor:** Open Chromium browser. Open Mousepad or Geany text editor.\n\n## Module 2: Introduction to Python with Thonny\n\n*   **Experiment 2.1: Hello, World!:** Open Thonny IDE. Type `print(\"Hello, World!\")` in the editor pane. Click Run button. See output in Shell pane.\n*   **Experiment 2.2: Variables & Input:**\n    ```python\n    name = input(\"Enter your name: \")\n    print(f\"Hello, {name}!\")\n    age = int(input(\"Enter your age: \")) # Convert input to integer\n    print(f\"You will be {age + 1} next year.\")\n    ```\n*   **Experiment 2.3: Conditional Statements (If/Else):**\n    ```python\n    num = int(input(\"Enter a number: \"))\n    if num > 10:\n        print(\"Number is large.\")\n    elif num == 10:\n        print(\"Number is 10.\")\n    else:\n        print(\"Number is small.\")\n    ```\n*   **Experiment 2.4: Loops (For/While):**\n    ```python\n    # For loop\n    for i in range(5):\n        print(f\"Counting: {i}\")\n    \n    # While loop\n    count = 0\n    while count < 3:\n        print(\"Looping...\")\n        count += 1\n    ```\n\n## Module 3: Introduction to GPIO Control (Requires Breadboard/Components)\n\n*   **Safety:** Ensure correct wiring! Use 3.3V logic. Use resistors for LEDs.\n*   **Pinout:** Refer to KinetiCore Pi pinout diagram.\n*   **Experiment 3.1: Blinking an LED with Python:**\n    *   **Circuit:** Connect GND pin to breadboard '-' rail. Connect GPIO Pin 17 (example) -> Resistor (330Ω) -> LED Anode -> LED Cathode -> GND rail.\n    *(Diagram of Pi GPIO LED circuit)*\n    *   **Code (using `gpiozero` library):**\n        ```python\n        from gpiozero import LED\n        from time import sleep\n        \n        led = LED(17) # Use GPIO number (BCM mode)\n        \n        while True:\n            led.on()\n            sleep(1)\n            led.off()\n            sleep(1)\n        ```\n    *   **Run:** Run script from Thonny or Terminal (`python your_script.py`). LED should blink.\n*   **Experiment 3.2: Reading a Button with Python:**\n    *   **Circuit:** Connect Button: One side to 3.3V pin, other side to GPIO Pin 18 (example) AND also through 10kΩ resistor to GND (pull-down).\n    *(Diagram of Pi GPIO button circuit)*\n    *   **Code:**\n        ```python\n        from gpiozero import Button, LED\n        from time import sleep\n        \n        button = Button(18) # GPIO 18\n        led = LED(17)      # GPIO 17\n        \n        while True:\n            if button.is_pressed:\n                led.on()\n            else:\n                led.off()\n            sleep(0.1)\n        ```\n    *   **Run:** LED should light when button pressed.\n\n## Module 4: Using Scratch for GPIO\n\n*   **Experiment 4.1:** Open Scratch 3 (usually pre-installed). Look for GPIO extension blocks. Recreate the Blink and Button examples using Scratch visual blocks.\n\n## Project Ideas\n\n*   **Traffic Light Simulator:** Control Red/Yellow/Green LEDs with timed sequences.\n*   **Reaction Game:** Light LED, measure time until button pressed.\n*   **Temperature Logger:** Read temp sensor (requires specific sensor/library) and log data to a file using Python.\n*   **Simple Web Server with GPIO Control:** Use Python (e.g., Flask library) to create a web page that controls LEDs connected to GPIO pins.\n\nExplore the power of a full computer combined with hardware control!"}
{"_id": "LL-MCU-003_SWG_v1.0", "product_id": "LL-MCU-003", "product_name": "Compute Hub Kit (KinetiCore Pi)", "doc_type": "Software Guide", "version": "1.0", "title": "Compute Hub Software Environment Guide", "language": "en-US", "format": "Markdown", "text": "# Compute Hub Software Environment Guide (v1.0)\n\nNavigating the software tools on your KinetiCore Pi.\n\n## Raspberry Pi OS Desktop\n\n*   **Panel/Taskbar:** Located at the top (usually). Contains Main Menu, application shortcuts, system tray (clock, network, volume, Bluetooth).\n*   **Main Menu (Raspberry Icon):** Access installed applications categorized under Programming, Education, Office, Internet, Games, Accessories, System Tools.\n*   **File Manager:** Browse files and directories on the MicroSD card and connected USB drives.\n*   **Terminal:** Command-line interface for interacting with the Linux operating system.\n\n## Key Pre-installed Software\n\n*   **Thonny IDE:**\n    *   **Purpose:** Beginner-friendly Python Integrated Development Environment.\n    *   **Features:** Code editor with syntax highlighting, Python Shell (REPL) for testing commands, integrated debugger, easy script execution.\n    *   **Location:** Usually under Programming menu.\n*   **Scratch 3:**\n    *   **Purpose:** Block-based visual programming language, great for learning coding concepts.\n    *   **Features:** Drag-and-drop blocks, sprite animation, interactive stories/games. Includes extensions for controlling Raspberry Pi GPIO pins.\n    *   **Location:** Usually under Programming menu.\n*   **Chromium Web Browser:**\n    *   **Purpose:** Browsing the internet.\n    *   **Location:** Usually under Internet menu or on panel.\n*   **Text Editor (Mousepad / Geany):**\n    *   **Purpose:** Simple text file editing, useful for configuration files or basic notes.\n    *   **Location:** Usually under Accessories menu.\n*   **GPIO Libraries (Python):**\n    *   **`gpiozero`:** (Recommended for beginners) High-level, object-oriented library making GPIO control easy (e.g., `led = LED(17)`, `button = Button(18)`).\n    *   **`RPi.GPIO`:** (More traditional) Lower-level library providing direct pin control functions (`GPIO.setup()`, `GPIO.output()`, `GPIO.input()`).\n    *   These are typically pre-installed on the Kinetic Learning Environment.\n*   **Kinetic Guides/Tutorials:**\n    *   Custom application or web links providing guided projects and learning resources specific to the kit.\n    *   **Location:** Check Desktop or Main Menu.\n\n## Connecting to Wi-Fi\n\n*   Click the Network icon (Wi-Fi symbol or Ethernet symbol) in the top-right corner of the panel.\n*   Select your Wi-Fi network SSID from the list.\n*   Enter your Wi-Fi password when prompted.\n\n## Updating Software\n\n*   **Recommended:** Keep the system updated for security and features.\n*   **Method 1 (Graphical):** Look for 'Add / Remove Software' or 'Software Updater' in the menu (under Preferences or Accessories).\n*   **Method 2 (Terminal):** Open Terminal and run:\n    ```bash\n    sudo apt update\n    sudo apt full-upgrade -y \n    ```\n    Enter your password when prompted. Requires internet connection.\n\n## Shutting Down / Restarting\n\n*   **ALWAYS shut down properly before disconnecting power** to avoid SD card corruption.\n*   Go to Main Menu > Logout > Shutdown (or Reboot).\n*   Wait for activity lights on the Pi board to stop blinking completely before unplugging power supply.\n\nExplore the different software tools to start programming and creating!"}
{"_id": "LL-MCU-003_FAQ_v1.1", "product_id": "LL-MCU-003", "product_name": "Compute Hub Kit (KinetiCore Pi)", "doc_type": "Troubleshooting FAQ", "version": "1.1", "title": "Compute Hub Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# Compute Hub Troubleshooting FAQ (v1.1)\n\nResolving common KinetiCore Pi issues.\n\n## Boot & Display Issues\n\n*   **No Display Output (Black Screen):**\n    *   Check HDMI cable connections at both Pi and Monitor/TV.\n    *   Ensure monitor is ON and set to the correct HDMI input source.\n    *   Verify MicroSD card is properly inserted into the Pi.\n    *   Check Power Supply connection. Is the red power LED on the Pi lit?\n    *   Try a different HDMI port on the Pi (if it has multiple).\n    *   Try a different HDMI cable or monitor.\n    *   SD card image might be corrupted - try re-flashing (see advanced help online).\n*   **Rainbow Square / Lightning Bolt Icon on Screen:**\n    *   **Indicates Under-Voltage.** The Power Supply is not providing enough power/stable voltage. Use the official/recommended power supply for your Pi model. Avoid long/thin USB cables.\n*   **Stuck at Boot / Kernel Panic Message:**\n    *   SD card corruption is common cause. Try re-flashing the Raspberry Pi OS image.\n    *   Power supply issue.\n    *   Hardware fault (less common).\n\n## Peripheral Issues\n\n*   **Keyboard/Mouse Not Working:**\n    *   Check USB connection.\n    *   Try different USB port.\n    *   Try different keyboard/mouse.\n    *   Ensure Pi has booted fully.\n*   **Cannot Connect to Wi-Fi:**\n    *   Double-check Wi-Fi password (case-sensitive).\n    *   Ensure correct network selected.\n    *   Check if Wi-Fi country is set correctly (via `raspi-config` in terminal or graphical settings).\n    *   Move Pi closer to router.\n    *   Restart Pi and router.\n*   **Bluetooth Device Not Pairing:**\n    *   Ensure Bluetooth is enabled on Pi (via panel icon or `bluetoothctl` in terminal).\n    *   Make Bluetooth device discoverable.\n    *   Check range.\n\n## Software & Programming Issues\n\n*   **Python Script Error (e.g., ModuleNotFound):**\n    *   Ensure necessary libraries (like `gpiozero`) are installed. Use Thonny's Tools > Manage Packages or Terminal: `pip install <library_name>`.\n    *   Check code for typos in library/function names.\n*   **GPIO Not Working (LEDs/Buttons):**\n    *   **Wiring Error:** Double-check connections against pinout diagram (GND, 3.3V/5V, GPIO pin, resistors).\n    *   **Code Error:** Using correct GPIO pin number (BCM numbering usually preferred)? Pin configured as INPUT/OUTPUT? Logic correct?\n    *   **Permissions (Less Common):** Ensure 'pi' user has GPIO access (usually default).\n    *   **3.3V Logic:** Remember Pi GPIOs are 3.3V. Damage can occur if connected directly to 5V inputs.\n*   **Scratch GPIO Extension Not Working:** Ensure extension is enabled in Scratch. Check physical GPIO connections.\n*   **System Slow / Freezing:**\n    *   Check resource usage (Task Manager or `top` command in terminal). Close demanding applications.\n    *   Ensure adequate cooling (heatsinks installed, good airflow). Pi can throttle performance if overheating.\n    *   Check SD card health (can wear out over time).\n\n## SD Card Issues\n\n*   **Corruption:** Common issue, often caused by improper shutdown (disconnecting power without shutting down OS first). Requires re-flashing the OS image onto the SD card using Raspberry Pi Imager tool on another computer.\n*   **Read-Only Filesystem Errors:** Often indicates SD card corruption.\n\n## Contacting Support / Further Help\n\n*   Many issues are common Raspberry Pi issues. Search official Raspberry Pi documentation and forums (raspberrypi.org) for extensive troubleshooting guides.\n*   For kit-specific software/hardware issues, visit Kinetic Constructs support."}
{"_id": "LL-MCU-003_SI_v1.0", "product_id": "LL-MCU-003", "product_name": "Compute Hub Kit (KinetiCore Pi)", "doc_type": "Safety Information", "version": "1.0", "title": "Compute Hub Safety Information", "language": "en-US", "format": "Markdown", "text": "# Compute Hub Safety Information (v1.0)\n\nSafe use of your KinetiCore Pi computer kit.\n\n*   **WARNING: CHOKING HAZARD -- Small parts if case opened or kit includes small components. Base kit may be suitable for 13+, but associated electronics projects need appropriate age considerations.**\n*   **Recommended Age:** 13+ Requires understanding of computer operation and basic electronics if using GPIO.\n*   **Electrical Safety:** Operates at low DC voltage (5V). However, connects to mains power via supplied Power Adapter.\n    *   Use ONLY the provided Power Supply designed for your specific KinetiCore Pi model. Incorrect voltage/current can damage the board.\n    *   Plug adapter into a properly grounded wall outlet. Do not use damaged adapters or cables.\n    *   The Pi board itself contains sensitive electronic components. Handle with care, especially when outside the case.\n    *   **Static Discharge (ESD):** The Pi board is sensitive to static. Ground yourself before handling the bare board (touch large metal object).\n    *   Do not expose the Pi or peripherals to water/liquids.\n*   **GPIO Safety (When doing electronics projects):**\n    *   **3.3V Logic Levels:** Raspberry Pi GPIO pins use 3.3V. DO NOT connect 5V logic outputs from other devices directly to Pi GPIO input pins without level shifting. DO NOT connect Pi GPIO outputs directly to devices requiring 5V logic input without level shifting. Connecting 5V directly to a 3.3V pin can permanently damage the Pi.\n    *   **Current Limits:** Do not draw excessive current from GPIO pins (check Pi documentation for limits, usually low mA). Use transistors or drivers to control high-current devices like motors.\n    *   **Avoid Short Circuits:** Double-check wiring before applying power. Do not short 3.3V or 5V pins to GND or to each other.\n*   **Heat:** The Pi processor can become warm or hot during heavy use. Ensure adequate ventilation. Use included heatsinks if provided. Do not touch hot heatsinks.\n*   **Case:** Keep the Pi board inside the protective case during normal operation.\n*   **SD Card:** Handle MicroSD card carefully; avoid bending or static.\n*   **Shutdown Procedure:** Always shut down the operating system properly before disconnecting power to prevent SD card corruption.\n\nThis kit involves a functional computer; follow standard computer and electronics safety practices."}
{"_id": "LL-SNS-001_UG_v1.0", "product_id": "LL-SNS-001", "product_name": "Environmental Sensor Pack", "doc_type": "User Guide", "version": "1.0", "title": "Environmental Sensor Pack User Guide", "language": "en-US", "format": "Markdown", "text": "# Environmental Sensor Pack User Guide (v1.0)\n\nAdding environmental sensing to your microcontroller projects.\n\n## Compatibility\n\n*   Designed for use with Kinetic Constructs MicroController Kits (KinetiCore Uno - LL-MCU-001, KinetiCore ESP - LL-MCU-002, KinetiCore Pi - LL-MCU-003) or other compatible microcontroller boards (Arduino, ESP32, Raspberry Pi).\n*   Requires appropriate programming interface (Blocks, MicroPython, Python) and potentially specific libraries for each sensor.\n\n## Pack Contents\n\n*   1x Temperature & Humidity Sensor Module (e.g., DHT11, DHT22, or BME280)\n*   1x Barometric Pressure Sensor Module (e.g., BMP180, BMP280, or integrated in BME280)\n*   1x Gas Sensor Module (e.g., MQ-2 for Smoke/LPG/CO, or other type - Check Label!)\n*   Jumper Wires (Female-Male or Female-Female as needed for board connection)\n\n*(Illustrations of each sensor module showing pin labels)*\n\n## Sensor Descriptions & Pinouts (Examples - **CHECK YOUR SPECIFIC MODULES**)\n\n*   **DHT11/DHT22 (Temp/Humidity):**\n    *   Pins: VCC (3.3V-5V), GND, Data.\n    *   Digital one-wire communication.\n    *   Needs specific library in code.\n*   **BME280 (Temp/Humidity/Pressure):**\n    *   Pins: VCC (often 3.3V ONLY), GND, SCL (I2C Clock), SDA (I2C Data).\n    *   Uses I2C communication protocol.\n    *   Needs specific library. Requires connecting to board's I2C pins.\n*   **BMP180/BMP280 (Pressure/Temp):**\n    *   Pins: VCC (often 3.3V ONLY), GND, SCL, SDA.\n    *   Uses I2C communication.\n    *   Needs specific library.\n*   **MQ-Series Gas Sensor:**\n    *   Pins: VCC (Usually 5V), GND, AOUT (Analog Output), DOUT (Digital Output - optional).\n    *   **Requires Burn-in:** Often needs to be powered on for minutes/hours before readings stabilize.\n    *   **AOUT:** Connect to microcontroller's Analog Input pin (ADC). Reads varying voltage based on gas concentration. Requires calibration/mapping in code.\n    *   **DOUT:** Outputs HIGH/LOW if gas concentration exceeds a threshold set by an onboard potentiometer. Connect to digital input pin.\n    *   **Check specific MQ sensor type (MQ-2, MQ-7, etc.) for gases detected.**\n\n## Connecting to Microcontroller\n\n1.  **Identify Pins:** Determine the VCC, GND, and Data/Signal pins (SDA/SCL for I2C, Data for DHT, AOUT/DOUT for MQ) on your sensor module.\n2.  **Identify Board Pins:** Find corresponding power pins (3.3V or 5V - **USE CORRECT VOLTAGE!**), GND pins, and appropriate data pins (Analog, Digital, I2C SDA/SCL) on your KinetiCore board.\n3.  **Wire Connections:** Use jumper wires to connect:\n    *   Sensor VCC -> Board 3.3V or 5V (as required by sensor).\n    *   Sensor GND -> Board GND.\n    *   Sensor Data/Signal Pin(s) -> Board Data Pin(s) (Analog In for MQ AOUT, Digital In for MQ DOUT/DHT Data, I2C SDA/SCL pins for BME/BMP).\n    *(Diagrams: Show example wiring for each sensor type to Uno, ESP, Pi respectively)*\n\n## Programming\n\n*   Reading these sensors requires specific code libraries.\n*   **Kinetic Blocks:** May require installing sensor-specific library extensions.\n*   **MicroPython/Python:** Need to install/upload appropriate libraries (e.g., `dht`, `bme280`, libraries for specific MQ sensors or generic ADC reading). Libraries often provide functions like `read_temperature()`, `read_pressure()`, `read_gas_level()`.\n*   Refer to API References (LL-SNS-001_API_v1.0) and specific sensor datasheets/library examples.\n\nAlways double-check pinouts and voltage requirements before connecting!"}
{"_id": "LL-SNS-001_API_v1.0", "product_id": "LL-SNS-001", "product_name": "Environmental Sensor Pack", "doc_type": "API Reference (Python/MicroPython Examples)", "version": "1.0", "title": "Environmental Sensor Pack API Reference Examples", "language": "en-US", "format": "Markdown", "text": "# Environmental Sensor Pack API Reference Examples (v1.0)\n\nCode examples for reading environmental sensors.\n\n**(Note: Assumes necessary libraries are installed/uploaded. Pin numbers are examples - use pins appropriate for your board and wiring.)**\n\n## DHT11/DHT22 Temp/Humidity Sensor (Digital One-Wire)\n\n```python\n# MicroPython Example (needs dht library)\nimport machine\nimport dht\nimport time\n\nd = dht.DHT22(machine.Pin(4)) # Or DHT11; Connect Data to GPIO 4\n\ntry:\n    d.measure()\n    temp_c = d.temperature()\n    humidity = d.humidity()\n    print(f'Temp: {temp_c}°C, Humidity: {humidity}%')\nexcept OSError as e:\n    print('Failed to read DHT sensor.')\n\n# Python (Raspberry Pi) Example (needs Adafruit_DHT library)\n# import Adafruit_DHT\n# sensor = Adafruit_DHT.DHT22\n# pin = 4 # GPIO 4 (BCM)\n# humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)\n# if humidity is not None and temperature is not None:\n#     print(f'Temp={temperature:0.1f}*C  Humidity={humidity:0.1f}%')\n# else:\n#     print('Failed to get DHT reading.')\n```\n\n## BME280 Temp/Humidity/Pressure Sensor (I2C)\n\n```python\n# MicroPython Example (needs bme280 library)\nimport machine\nimport bme280 # Assumes library is available\n\n# Default I2C pins for ESP32: SDA=GPIO21, SCL=GPIO22\n# Default I2C pins for Pi: SDA=GPIO2, SCL=GPIO3\ni2c = machine.I2C(scl=machine.Pin(22), sda=machine.Pin(21)) \n# Check BME280 I2C address (often 0x76 or 0x77)\nbme = bme280.BME280(i2c=i2c, address=0x76)\n\n# Read values (often returns strings)\n# Use bme.values tuple for float values\ntemp_str, pressure_str, humidity_str = bme.read_compensated_data() \nprint(f\"Temp: {temp_str}, Pressure: {pressure_str}, Humidity: {humidity_str}\")\n\n# Python (Raspberry Pi) Example (needs adafruit_bme280 library)\n# import board\n# import adafruit_bme280.basic as adafruit_bme280\n# i2c = board.I2C() # uses board.SCL and board.SDA\n# bme280 = adafruit_bme280.Adafruit_BME280_I2C(i2c, address=0x76)\n# print(f\"\\nTemperature: {bme280.temperature:.1f} C\")\n# print(f\"Humidity: {bme280.relative_humidity:.1f} %\")\n# print(f\"Pressure: {bme280.pressure:.1f} hPa\")\n```\n\n## MQ-Series Gas Sensor (Analog Output)\n\n```python\n# MicroPython Example (reading Analog Output)\nimport machine\nimport time\n\nadc_pin = 34 # Example ADC pin on ESP32\nadc = machine.ADC(machine.Pin(adc_pin))\nadc.atten(machine.ADC.ATTN_11DB) # Set for 0-3.3V range\n\n# Note: Converting ADC value to PPM requires calibration\n# based on sensor datasheet curves, load resistor, temp/humidity.\n# This example just reads the raw analog value (0-4095).\nwhile True:\n    raw_value = adc.read()\n    print(f\"Gas Sensor Raw ADC Value: {raw_value}\")\n    time.sleep(1)\n\n# Python (Raspberry Pi) Example (requires ADC like MCP3008 via SPI)\n# This is more complex as Pi lacks built-in ADC.\n# import Adafruit_MCP3008\n# import time\n# SPI_PORT   = 0\n# SPI_DEVICE = 0\n# mcp = Adafruit_MCP3008.MCP3008(spi=SPI.SpiDev(SPI_PORT, SPI_DEVICE))\n# while True:\n#     value = mcp.read_adc(0) # Read channel 0\n#     print(f\"Gas Sensor Raw ADC Value: {value}\")\n#     time.sleep(1)\n```\n\n## MQ-Series Gas Sensor (Digital Output)\n\n```python\n# MicroPython Example (reading Digital Output)\nimport machine\nimport time\n\ndout_pin = 25 # Example digital input pin\ngas_sensor_digital = machine.Pin(dout_pin, machine.Pin.IN)\n\nwhile True:\n    if gas_sensor_digital.value() == 0: # Digital out often goes LOW when triggered\n        print(\"Gas Detected! (Threshold Exceeded)\")\n    else:\n        print(\"Gas Level OK.\")\n    time.sleep(0.5)\n\n# Python (Raspberry Pi) Example\n# from gpiozero import InputDevice\n# import time\n# gas_sensor_digital = InputDevice(25) # GPIO 25\n# while True:\n#     if gas_sensor_digital.is_active: # Assumes active low\n#         print(\"Gas Detected! (Threshold Exceeded)\")\n#     else:\n#         print(\"Gas Level OK.\")\n#     time.sleep(0.5)\n```\n\n**Always consult the specific sensor datasheet and library documentation for accurate usage, calibration, and pin requirements.**"}
{"_id": "LL-SNS-001_SI_v1.0", "product_id": "LL-SNS-001", "product_name": "Environmental Sensor Pack", "doc_type": "Safety Information", "version": "1.0", "title": "Environmental Sensor Pack Safety Information", "language": "en-US", "format": "Markdown", "text": "# Environmental Sensor Pack Safety Information (v1.0)\n\nSafe handling of environmental sensors.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (sensor modules, wires). Not for children under 3 years.**\n*   **Recommended Age:** 10+ (Requires connection to microcontroller kit).\n*   **Electrical Safety:** These are low-voltage DC components.\n    *   **Voltage Compatibility:** CRITICAL - Check the operating voltage for EACH sensor module (printed on board or in datasheet). Connect VCC ONLY to the correct voltage pin on your microcontroller (e.g., 3.3V for BME280, potentially 5V for MQ sensors). Applying incorrect voltage can permanently damage the sensor.\n    *   Wire connections carefully (VCC, GND, Data pins).\n    *   Handle modules by edges; avoid static discharge (ESD).\n    *   Do not expose to water/liquids (especially humidity sensor!).\n*   **Gas Sensors (MQ Series):**\n    *   **Heat:** These sensors often contain a small internal heater and can get warm/hot during operation. Allow space for airflow and avoid touching after prolonged use.\n    *   **Burn-in:** Require initial power-on period for stabilization. Operate in well-ventilated area during burn-in and normal use.\n    *   **Specificity:** MQ sensors react to a range of gases. They are generally NOT suitable for safety-critical applications requiring precise gas identification or life support. They indicate presence/relative level, not exact concentration without calibration.\n    *   **Do Not Inhale Near Sensor:** Avoid directly inhaling air very close to the sensor while it's operating.\n*   **General Handling:** Protect sensor elements from dust, physical impact, and contaminants."}
{"_id": "LL-SNS-002_UG_v1.0", "product_id": "LL-SNS-002", "product_name": "Motion & Sound Sensor Pack", "doc_type": "User Guide", "version": "1.0", "title": "Motion & Sound Sensor Pack User Guide", "language": "en-US", "format": "Markdown", "text": "# Motion & Sound Sensor Pack User Guide (v1.0)\n\nAdding motion and sound detection to your projects.\n\n## Compatibility\n\n*   Designed for use with Kinetic Constructs MicroController Kits (Uno, ESP, Pi) or other compatible boards.\n*   Requires appropriate programming interface and libraries.\n\n## Pack Contents\n\n*   1x PIR Motion Sensor Module (Passive Infrared)\n*   1x Accelerometer/Gyroscope Module (e.g., MPU-6050)\n*   1x Microphone Sensor Module (Sound Detection)\n*   1x Ultrasonic Distance Sensor Module (e.g., HC-SR04)\n*   Jumper Wires\n\n*(Illustrations of each sensor module showing pin labels)*\n\n## Sensor Descriptions & Pinouts (Examples - **CHECK YOUR SPECIFIC MODULES**)\n\n*   **PIR Motion Sensor:**\n    *   Pins: VCC (Often 5V tolerant), GND, OUT (Digital signal - HIGH when motion detected).\n    *   Detects changes in infrared radiation (body heat). Has detection range/angle.\n    *   Often has adjustable sensitivity and delay potentiometers.\n*   **MPU-6050 (Accelerometer/Gyro):**\n    *   Pins: VCC (3.3V or 5V tolerant - CHECK!), GND, SCL (I2C Clock), SDA (I2C Data).\n    *   Uses I2C communication.\n    *   Measures acceleration (G-force) along X/Y/Z axes and rotation rate (degrees/sec) around X/Y/Z axes.\n    *   Needs specific library.\n*   **Microphone Sensor Module:**\n    *   Pins: VCC (3.3V or 5V), GND, AOUT (Analog output - signal level varies with sound loudness), DOUT (Digital output - HIGH/LOW when sound exceeds threshold set by potentiometer).\n    *   Connect AOUT to ADC pin for loudness measurement. Connect DOUT to digital pin for simple sound detection.\n*   **HC-SR04 (Ultrasonic Distance):**\n    *   Pins: VCC (Usually 5V), GND, Trig (Trigger - Pulse Output from Microcontroller), Echo (Echo - Pulse Input to Microcontroller).\n    *   Works by sending sound pulse (Trig) and measuring time until echo returns (Echo).\n    *   Requires precise timing in code. **Needs 5V supply, but Echo pin output is 5V - REQUIRES level shifter or voltage divider to connect safely to 3.3V ESP/Pi input pins.** Uno inputs are 5V tolerant.\n\n## Connecting to Microcontroller\n\n1.  **Identify Pins:** Determine VCC, GND, Signal pins (OUT, SDA/SCL, AOUT/DOUT, Trig/Echo) on sensor.\n2.  **Identify Board Pins:** Find corresponding Power (3.3V/5V), GND, Data (Digital, Analog, I2C) pins on your KinetiCore board.\n3.  **Wire Connections:** Use jumper wires. **PAY CLOSE ATTENTION TO VOLTAGE LEVELS (3.3V vs 5V) for VCC and signal lines, especially for ESP/Pi.**\n    *   Sensor VCC -> Board 3.3V / 5V (as required).\n    *   Sensor GND -> Board GND.\n    *   Sensor Signal(s) -> Board Data Pin(s) (Digital for PIR OUT/Mic DOUT, Analog for Mic AOUT, I2C for MPU-6050, Digital Out for Trig, Digital In for Echo **with level shifting if needed**).\n    *(Diagrams: Show example wiring for each sensor type to Uno, ESP, Pi respectively, highlighting level shifting for HC-SR04 Echo to 3.3V boards)*\n\n## Programming\n\n*   Requires specific code/libraries.\n*   Refer to API References (LL-SNS-002_API_v1.0) and sensor datasheets/library examples.\n\nAlways double-check pinouts and voltage requirements!"}
{"_id": "LL-SNS-002_API_v1.0", "product_id": "LL-SNS-002", "product_name": "Motion & Sound Sensor Pack", "doc_type": "API Reference (Python/MicroPython Examples)", "version": "1.0", "title": "Motion & Sound Sensor Pack API Reference Examples", "language": "en-US", "format": "Markdown", "text": "# Motion & Sound Sensor Pack API Reference Examples (v1.0)\n\nCode examples for reading motion and sound sensors.\n\n**(Note: Assumes necessary libraries installed/uploaded. Pin numbers are examples. Check voltage compatibility!)**\n\n## PIR Motion Sensor (Digital Output)\n\n```python\n# MicroPython Example\nimport machine\nimport time\n\npir_pin = 14 # Example digital input pin\nmotion_sensor = machine.Pin(pir_pin, machine.Pin.IN)\n\nwhile True:\n    if motion_sensor.value() == 1: # Assumes HIGH when motion detected\n        print(\"Motion Detected!\")\n        # Add delay to avoid rapid re-triggering\n        time.sleep(5) \n    # else: \n    #     print(\"No motion.\")\n    time.sleep(0.1)\n\n# Python (Raspberry Pi) Example\n# from gpiozero import MotionSensor\n# import time\n# pir = MotionSensor(14) # GPIO 14\n# while True:\n#     pir.wait_for_motion()\n#     print(\"Motion Detected!\")\n#     pir.wait_for_no_motion()\n#     print(\"Motion Stopped.\")\n```\n\n## MPU-6050 Accelerometer/Gyroscope (I2C)\n\n```python\n# MicroPython Example (needs mpu6050 library)\nimport machine\nimport mpu6050 # Assumes library available\n\ni2c = machine.I2C(scl=machine.Pin(22), sda=machine.Pin(21))\nmpu = mpu6050.accel(i2c) # Check library usage\n\nwhile True:\n    acceleration = mpu.get_values() # Check library for exact function\n    # Returns dict like {'AcX': x, 'AcY': y, 'AcZ': z, 'GyX': gx, ...}\n    print(f\"Accel: X={acceleration['AcX']}, Y={acceleration['AcY']}, Z={acceleration['AcZ']}\")\n    # print(f\"Gyro: X={acceleration['GyX']}, Y={acceleration['GyY']}, Z={acceleration['GyZ']}\")\n    time.sleep(0.2)\n\n# Python (Raspberry Pi) Example (needs adafruit_mpu6050 library)\n# import board\n# import adafruit_mpu6050\n# i2c = board.I2C()\n# mpu = adafruit_mpu6050.MPU6050(i2c)\n# while True:\n#     print(f\"Acceleration: X={mpu.acceleration[0]:.2f}, Y={mpu.acceleration[1]:.2f}, Z={mpu.acceleration[2]:.2f} m/s^2\")\n#     print(f\"Gyro: X={mpu.gyro[0]:.2f}, Y={mpu.gyro[1]:.2f}, Z={mpu.gyro[2]:.2f} rad/s\")\n#     time.sleep(0.2)\n```\n\n## Microphone Sensor Module (Analog Output Example)\n\n```python\n# MicroPython Example\nimport machine\nimport time\n\nadc_pin = 35 # Example ADC pin\nmic_adc = machine.ADC(machine.Pin(adc_pin))\nadc.atten(machine.ADC.ATTN_11DB)\n\nwhile True:\n    sound_level = mic_adc.read() # Raw ADC value 0-4095\n    print(f\"Sound Level (Analog): {sound_level}\")\n    time.sleep(0.1)\n\n# Python (Raspberry Pi) Example (requires ADC like MCP3008)\n# import Adafruit_MCP3008\n# ... (Setup MCP3008 as in Gas Sensor example) ...\n# while True:\n#     value = mcp.read_adc(1) # Read channel 1\n#     print(f\"Sound Level (Analog): {value}\")\n#     time.sleep(0.1)\n```\n\n## HC-SR04 Ultrasonic Distance Sensor\n\n```python\n# MicroPython Example (needs hcsr04 library or manual timing)\nimport machine\nimport time\nfrom hcsr04 import HCSR04 # Assumes library available\n\n# Connect Trig to GPIO 12, Echo to GPIO 13\n# ** WARNING: If using 3.3V board (ESP, Pi), Echo pin needs voltage divider! **\nsensor = HCSR04(trigger_pin=12, echo_pin=13)\n\nwhile True:\n    try:\n        distance_cm = sensor.distance_cm()\n        print(f'Distance: {distance_cm:.1f} cm')\n    except OSError as e:\n        print('Failed to read sensor.')\n    time.sleep(0.2)\n\n# Python (Raspberry Pi) Example (using gpiozero - handles timing)\n# ** WARNING: Echo pin needs voltage divider for Pi's 3.3V input! **\n# from gpiozero import DistanceSensor\n# from time import sleep\n# \n# # Assuming Echo connected via voltage divider to GPIO 24, Trig to GPIO 23\n# sensor = DistanceSensor(echo=24, trigger=23)\n# \n# while True:\n#     print(f'Distance: {sensor.distance * 100:.1f} cm') # sensor.distance is in meters\n#     sleep(0.2)\n```\n\n**Consult sensor datasheets and library documentation. Pay critical attention to voltage level compatibility (especially HC-SR04 Echo pin)!**"}
{"_id": "LL-SNS-002_SI_v1.0", "product_id": "LL-SNS-002", "product_name": "Motion & Sound Sensor Pack", "doc_type": "Safety Information", "version": "1.0", "title": "Motion & Sound Sensor Pack Safety Information", "language": "en-US", "format": "Markdown", "text": "# Motion & Sound Sensor Pack Safety Information (v1.0)\n\nSafe handling of motion and sound sensors.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (sensor modules, wires). Not for children under 3 years.**\n*   **Recommended Age:** 10+ (Requires connection to microcontroller kit).\n*   **Electrical Safety:** Low-voltage DC components.\n    *   **Voltage Compatibility:** CRITICAL - Check operating voltage for EACH module (VCC pin). MPU-6050 might be 3.3V only. PIR often 5V tolerant. HC-SR04 requires 5V VCC, but its ECHO output pin is 5V logic level. **You MUST use a level shifter or voltage divider circuit to connect the HC-SR04 Echo pin to a 3.3V input pin (like on ESP32 or Raspberry Pi) to avoid damage.** Arduino Uno inputs are 5V tolerant.\n    *   Wire carefully (VCC, GND, Signals).\n    *   Handle modules carefully, avoid static discharge (ESD).\n    *   Do not expose to water/liquids.\n*   **Ultrasonic Sensor (HC-SR04):** Emits high-frequency sound pulses, generally considered inaudible and safe. Avoid pointing directly into ear at very close range for prolonged periods.\n*   **PIR Sensor:** Passive device, detects infrared. No emitted radiation.\n*   **General Handling:** Protect sensor elements (PIR lens, microphone diaphragm, ultrasonic transducers) from dust, impact, contaminants."}
{"_id": "LL-THM-001_AM_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "Assembly Manual", "version": "1.0", "title": "Weather Station Builder Kit Assembly Manual", "language": "en-US", "format": "Markdown", "text": "# Weather Station Builder Kit Assembly Manual (v1.0)\n\nAssembling your mini weather station hardware.\n\n## Kit Contents Overview\n\n*   KinetiCore Microcontroller Board (e.g., Uno or ESP variant suitable for project)\n*   Temperature & Humidity Sensor (e.g., DHT22 or BME280)\n*   Barometric Pressure Sensor (e.g., BMP180/280 or integrated in BME280)\n*   (Optional: Light Sensor - Photoresistor or module)\n*   (Optional: Rain Sensor Module)\n*   (Optional: Small OLED or LCD Display Module)\n*   Weather Station Enclosure/Frame Parts\n*   Breadboard & Jumper Wires\n*   USB Cable\n*   Mounting Hardware (Screws, Standoffs)\n*   Software Info\n\n*(Illustrations of components and assembled station)*\n\n## Assembly Steps\n\n1.  **Mount Microcontroller:** Secure the KinetiCore board onto the designated spot on the enclosure base or frame using screws/standoffs.\n2.  **Mount Sensors:**\n    *   Place Temp/Humidity/Pressure sensor(s) in a location allowing good air exposure but protected from direct sun/rain (e.g., under an overhang in the enclosure).\n    *   Mount optional Light Sensor facing upwards.\n    *   Mount optional Rain Sensor where it can collect rain.\n    *   Secure sensors using appropriate hardware.\n3.  **Mount Display (If Included):** Attach OLED/LCD display to a visible position on the enclosure.\n4.  **Place Breadboard (Optional):** If needed for wiring, place breadboard inside enclosure.\n5.  **Wire Components to Microcontroller:**\n    *   **Power:** Connect sensor/display VCC pins to appropriate 3.3V/5V pins on microcontroller. Connect all GND pins to microcontroller GND.\n    *   **Data:** Connect sensor/display data pins (Digital, Analog, I2C SDA/SCL) to the correct corresponding pins on the microcontroller. **PAY ATTENTION TO VOLTAGE LEVELS (3.3V vs 5V)!** Refer to sensor/display pinouts and microcontroller pinout diagram.\n    *   Use breadboard if needed to distribute power or connect multiple devices to same pins (e.g., I2C).\n    *(Diagram: Shows wiring from sensors/display to microcontroller board)*\n6.  **Assemble Enclosure:** Close the weather station enclosure/frame parts.\n7.  **Connect Power/Programming:** Connect USB cable to microcontroller board for power and programming.\n\nAssembly Complete. Proceed to User Guide (UG) and programming guides (BCG/API)."}
{"_id": "LL-THM-001_UG_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "User Guide", "version": "1.0", "title": "Weather Station Builder Kit User Guide", "language": "en-US", "format": "Markdown", "text": "# Weather Station Builder Kit User Guide (v1.0)\n\nMonitoring the weather with your custom station.\n\n## Overview\n\n*   This kit allows you to build a device that reads environmental data (temperature, humidity, pressure) using sensors connected to a microcontroller.\n*   Data can be displayed locally (on an OLED/LCD screen) or sent to a computer (via Serial Monitor) or the internet (if using an IoT-capable board like KinetiCore ESP).\n\n## Hardware Setup Review\n\n*   Ensure all sensors, display (if used), and the microcontroller are correctly assembled and wired within the enclosure as per the Assembly Manual (AM).\n*   Connect the microcontroller board to your computer via USB.\n\n## Software Setup & Programming\n\n*   **IDE:** Use the appropriate IDE for your board and programming choice:\n    *   Kinetic Blocks IDE (Block-based)\n    *   Thonny IDE (for MicroPython on ESP32)\n    *   Arduino IDE (for C++ on Uno/ESP32)\n*   **Libraries:** You will need specific libraries installed in your IDE to read data from the sensors (e.g., DHT library, BME280 library, OLED display library).\n*   **Code:** Write code (Blocks/MicroPython/C++) to:\n    1.  Initialize sensors and display.\n    2.  Read data periodically from each sensor.\n    3.  Process data (e.g., calculate altitude from pressure).\n    4.  Display data on the screen OR print it to the Serial Monitor OR send it over Wi-Fi (see programming guides).\n\n## Running the Weather Station\n\n1.  **Upload Code:** Compile and upload your weather station code to the microcontroller board via USB.\n2.  **Observe Output:**\n    *   **Serial Monitor:** Open the Serial Monitor in your IDE to view sensor readings printed by your code.\n    *   **Display:** If using an OLED/LCD, readings should appear on the screen.\n    *   **Web/Cloud:** If programmed for IoT, check the web dashboard or cloud service you configured.\n3.  **Placement:** For accurate readings, place the assembled weather station outdoors in a location that is:\n    *   Shaded from direct sunlight (affects temperature).\n    *   Protected from direct rain (unless sensors/enclosure are weatherproof).\n    *   Allows good airflow.\n    *   (If Wi-Fi enabled) Within range of your Wi-Fi network.\n\n## Powering Standalone\n\n*   Once programmed, you can power the weather station using a USB power bank or USB wall adapter connected to the microcontroller's USB port, instead of keeping it connected to a computer.\n\nRefer to EPB, BCG, API documents for specific experiments, code blocks, and functions."}
{"_id": "LL-THM-001_EPB_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Weather Station Builder Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Weather Station Builder Experiment & Project Book (v1.0)\n\nExploring weather phenomena with sensors and code.\n\n## Introduction\n\n*   Understanding key weather parameters: Temperature, Humidity, Barometric Pressure.\n*   How electronic sensors measure these parameters.\n*   Using a microcontroller to read sensors and display/log data.\n\n## Experiment 1: Reading Temperature & Humidity\n\n*   **Goal:** Read and display Temp/Humidity from DHT or BME sensor.\n*   **Circuit:** Connect sensor VCC, GND, Data (or I2C) to microcontroller.\n*   **Code:** Write simple code (Blocks/MicroPython/C++) using appropriate library to read `temperature()` and `humidity()` values. Print values to Serial Monitor.\n*   **Observe:** See readings change. Breathe on sensor - humidity should increase. Warm sensor slightly - temperature should increase.\n\n## Experiment 2: Reading Barometric Pressure (& Altitude Estimation)\n\n*   **Goal:** Read pressure from BMP/BME sensor. Optionally estimate altitude change.\n*   **Circuit:** Connect I2C sensor (VCC, GND, SDA, SCL) to microcontroller I2C pins.\n*   **Code:** Use library to read `pressure()` (usually in Pascals or hPa). Print value.\n*   **Observe:** Pressure readings should be relatively stable but change slowly with weather systems (High pressure = clear weather, Low pressure = stormy weather).\n*   **Altitude Estimation (Advanced):** Pressure decreases with altitude. Use library function `readAltitude(seaLevelPressure)` or formula to estimate altitude based on current pressure and known sea level pressure for your area. Observe reading change as you move sensor up/down significantly (e.g., different floors).\n\n## Experiment 3: Displaying Data Locally\n\n*   **Goal:** Show sensor readings on OLED/LCD display.\n*   **Circuit:** Connect display (VCC, GND, SDA/SCL for I2C OLED, or multiple pins for LCD) to microcontroller.\n*   **Code:** Use display library to initialize display, clear screen, set cursor position, and print formatted sensor readings (`display.print(...)`, `display.show()`). Update display periodically in main loop.\n*   **Observe:** See live weather data on the small screen.\n\n## Experiment 4: Logging Data to Computer\n\n*   **Goal:** Send sensor data to PC for logging/graphing.\n*   **Circuit:** Sensors connected to microcontroller, microcontroller connected via USB.\n*   **Code:** Read sensors. Print data to Serial Monitor in a structured format (e.g., CSV - Comma Separated Values: `timestamp,temp,humidity,pressure`).\n*   **PC Software:** Use Arduino IDE Serial Plotter (simple graphing), or data logging software (e.g., CoolTerm, Putty) to save serial output to a file. Import file into spreadsheet software (Excel, Google Sheets) for graphing.\n\n## Project: Wi-Fi Weather Poster (Requires IoT Board)\n\n*   **Goal:** Send weather data over Wi-Fi to a cloud service (e.g., ThingSpeak, Adafruit IO) for remote viewing/graphing.\n*   **Circuit:** Sensors connected to KinetiCore ESP board.\n*   **Code:** Connect ESP to Wi-Fi. Read sensors. Format data. Use `urequests` (MicroPython) or HTTPClient (Arduino C++) library to send data via HTTP POST/GET requests to the cloud service API.\n\n## Project: Weather Alert System\n\n*   **Goal:** Trigger an LED or Buzzer if certain weather conditions are met.\n*   **Circuit:** Sensors, LED/Buzzer connected to microcontroller.\n*   **Code:** Read sensors. Use `If/Else` statements to check conditions (e.g., `If temperature < 5: turn_on_frost_warning_led()`, `If humidity > 90: buzz_for_rain_alert()`).\n\nLearn about your local environment by collecting and analyzing data!"}
{"_id": "LL-THM-001_BCG_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "Block Coding Guide", "version": "1.0", "title": "Weather Station Block Coding Guide", "language": "en-US", "format": "Markdown", "text": "# Weather Station Block Coding Guide (v1.0)\n\nUsing Kinetic Blocks IDE to program your weather station.\n\n## Prerequisites\n\n*   Kinetic Blocks IDE installed.\n*   Correct board selected (KinetiCore Uno / KinetiCore ESP).\n*   Correct Port selected.\n*   Necessary sensor/display libraries installed via Tools > Manage Libraries (e.g., search for DHT, BME280, SSD1306 OLED).\n\n## Required Library Blocks (Examples)\n\n*   You often need an 'Include Library' or 'Setup Sensor' block placed in the `Setup` part of your code.\n*   **DHT Sensor:**\n    *   `Setup DHT Sensor Type [DHT11/DHT22] on Pin [pin#]`: Initialize sensor.\n    *   `Read DHT Temperature`: Returns temperature value.\n    *   `Read DHT Humidity`: Returns humidity value.\n*   **BME280/BMP280 Sensor (I2C):**\n    *   `Setup BME280 Sensor`: Initialize I2C communication.\n    *   `Read BME280 Temperature / Pressure / Humidity / Altitude`: Returns respective values.\n*   **OLED Display (SSD1306 I2C):**\n    *   `Setup OLED Display I2C`: Initialize display.\n    *   `OLED Clear Display`\n    *   `OLED Set Cursor (X:[0], Y:[0])`\n    *   `OLED Print [text or value]`\n    *   `OLED Display Update`: Sends buffer to screen.\n*   **Serial Communication:**\n    *   `Serial Begin [9600]`\n    *   `Serial Print / Print Line [text or value]`\n\n## Example Project 1: Print Temp/Humidity to Serial Monitor\n\n```markdown\n// Setup Block\nSerial Begin [9600]\nSetup DHT Sensor Type [DHT22] on Pin [4] // Assuming DHT22 on Pin 4\n\n// Loop Block\nForever {\n  Temp = Read DHT Temperature\n  Humid = Read DHT Humidity\n  Serial Print \"Temp: \"\n  Serial Print Temp\n  Serial Print \" C, Humid: \"\n  Serial Print Humid\n  Serial Print Line \"%\"\n  Wait [2000] ms // Wait 2 seconds\n}\n```\n\n## Example Project 2: Display Temp/Pressure on OLED\n\n```markdown\n// Setup Block\nSerial Begin [9600] // Good for debugging\nSetup BME280 Sensor // Assuming BME280 connected via I2C\nSetup OLED Display I2C\nWait [100] ms\nOLED Clear Display\nOLED Display Update\n\n// Loop Block\nForever {\n  Temp = Read BME280 Temperature\n  Pressure = Read BME280 Pressure\n  \n  OLED Clear Display\n  OLED Set Cursor (X:0, Y:0)\n  OLED Print \"Temp: \"\n  OLED Print Temp\n  OLED Print \" C\"\n  \n  OLED Set Cursor (X:0, Y:10) // Move to next line (approx)\n  OLED Print \"Press:\"\n  OLED Print Pressure / 100 // Convert Pascals to hPa\n  OLED Print \" hPa\"\n  \n  OLED Display Update\n  Wait [5000] ms // Update every 5 seconds\n}\n```\n\n## Example Project 3: Wi-Fi Data Sender (Requires ESP Board & Wi-Fi Blocks)\n\n```markdown\n// Setup Block\nSerial Begin [115200]\nSetup Wi-Fi Connect SSID \"YOUR_SSID\" Password \"YOUR_PASSWORD\"\nSetup BME280 Sensor\n\n// Loop Block\nForever {\n  If Is Wi-Fi Connected? then {\n    Temp = Read BME280 Temperature\n    Pressure = Read BME280 Pressure\n    Humidity = Read BME280 Humidity\n    \n    // Construct URL for sending data (e.g., to ThingSpeak)\n    API_Key = \"YOUR_THINGSPEAK_WRITE_API_KEY\"\n    URL = \"http://api.thingspeak.com/update?api_key=\" + API_Key\n    URL = URL + \"&field1=\" + Temp\n    URL = URL + \"&field2=\" + Humidity\n    URL = URL + \"&field3=\" + Pressure / 100\n    \n    Serial Print Line \"Sending data...\"\n    Serial Print Line URL\n    Response = HTTP GET Request URL [URL] // Send data\n    Serial Print Line \"Response: \" + Response\n    \n    Wait [60000] ms // Send data every 60 seconds\n    \n  } else {\n    Serial Print Line \"Wi-Fi disconnected. Waiting...\"\n    Wait [5000] ms\n  }\n}\n```\n\n**Remember to install required libraries in the IDE!** Adapt code based on your specific sensors and board."}
{"_id": "LL-THM-001_API_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "MicroPython API Reference Examples", "version": "1.0", "title": "Weather Station MicroPython API Reference Examples", "language": "en-US", "format": "Markdown", "text": "# Weather Station MicroPython API Reference Examples (v1.0)\n\nCode examples for building weather station features in MicroPython.\n\n**(Note: Assumes KinetiCore ESP board and necessary libraries installed/uploaded. Refer to sensor/display datasheets and library docs for full details.)**\n\n## Reading Sensors\n\n*   **DHT22 Temperature & Humidity:** (See LL-SNS-001_API_v1.0)\n*   **BME280 Temperature, Humidity, Pressure (I2C):** (See LL-SNS-001_API_v1.0)\n*   **Photoresistor (Light Level - Analog):**\n    ```python\n    import machine\n    light_adc = machine.ADC(machine.Pin(36)) # Example ADC pin\n    light_adc.atten(machine.ADC.ATTN_11DB)\n    # Read raw value (0-4095), needs mapping to % or Lux\n    raw_light = light_adc.read() \n    light_percent = (raw_light / 4095) * 100\n    print(f\"Light Level: {light_percent:.1f}%\")\n    ```\n*   **Rain Sensor (Analog or Digital):**\n    *   *Analog Output:* Connect AO pin to ADC pin. Read value - lower value usually means more rain/wetness.\n    ```python\n    rain_adc = machine.ADC(machine.Pin(39))\n    rain_adc.atten(machine.ADC.ATTN_11DB)\n    rain_level = rain_adc.read()\n    print(f\"Rain Sensor (Analog): {rain_level}\")\n    ```\n    *   *Digital Output:* Connect DO pin to digital input pin. Reads LOW or HIGH when rain threshold (set by potentiometer) is crossed.\n    ```python\n    rain_digital = machine.Pin(25, machine.Pin.IN)\n    if rain_digital.value() == 0: # Often LOW when wet\n        print(\"Rain Detected!\")\n    ```\n\n## Displaying Data on OLED (SSD1306 I2C)\n\n```python\n# Needs ssd1306 library installed\nimport machine\nimport ssd1306\nimport time\n\ni2c = machine.I2C(scl=machine.Pin(22), sda=machine.Pin(21))\n# Check display width/height/address\ndisplay = ssd1306.SSD1306_I2C(128, 64, i2c)\n\n# --- Example Usage --- \ntemp = 25.5\nhumid = 60.2\n\ndisplay.fill(0) # Clear display (black background)\n\ndisplay.text(f\"Temp: {temp:.1f}C\", 0, 0) # Text, x, y coord\ndisplay.text(f\"Humid: {humid:.1f}%\", 0, 10)\n# Add more lines for pressure etc.\n\ndisplay.show() # Update the display\n```\n\n## Sending Data over Wi-Fi (Example: ThingSpeak using urequests)\n\n```python\nimport network\nimport time\nimport urequests\n\n# ... (Wi-Fi Connection Code - see LL-MCU-002_EPB_v1.1) ...\n\napi_key = 'YOUR_THINGSPEAK_WRITE_API_KEY'\nurl_base = 'http://api.thingspeak.com/update'\n\nwhile True:\n    if wlan.isconnected():\n        # --- Read sensor values --- \n        temp = 25.0 # Replace with actual sensor reading\n        humid = 55.0 # Replace with actual sensor reading\n        pressure = 1013.0 # Replace with actual sensor reading (in hPa)\n        \n        try:\n            # --- Construct URL --- \n            # Note: Handle potential errors if sensors fail\n            url = f\"{url_base}?api_key={api_key}&field1={temp}&field2={humid}&field3={pressure}\"\n            print(f\"Sending data: {url}\")\n            \n            # --- Send HTTP GET Request --- \n            response = urequests.get(url)\n            print(f\"Response: {response.status_code}, {response.text}\")\n            response.close()\n            \n        except Exception as e:\n            print(f\"Error sending data: {e}\")\n            \n        time.sleep(60) # Send every 60 seconds\n    else:\n        print(\"Wi-Fi disconnected...\")\n        # Attempt reconnect?\n        time.sleep(10)\n```\n\n## Combining Elements\n*   Integrate sensor reading, display updates, and network communication within the main `while True:` loop of your MicroPython script.\n*   Use `try...except` blocks for robust error handling, especially for network operations and sensor readings."}
{"_id": "LL-THM-001_FAQ_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "Troubleshooting FAQ", "version": "1.0", "title": "Weather Station Builder Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# Weather Station Builder Troubleshooting FAQ (v1.0)\n\nDebugging your weather monitoring project.\n\n## Sensor Reading Issues\n\n*   **Incorrect/Unrealistic Readings (Temp, Humidity, Pressure):**\n    *   **Wiring:** Double-check VCC, GND, Data/SDA/SCL connections.\n    *   **Voltage:** Ensure sensor is powered with correct voltage (3.3V vs 5V).\n    *   **Library:** Using correct library for the specific sensor model (DHT11 vs DHT22, BME280 vs BMP280)? Library installed correctly?\n    *   **Code:** Using correct pin numbers in code? Calling measurement/read functions correctly?\n    *   **Sensor Placement:** Is sensor exposed to direct sun, heat source, or moisture affecting readings?\n    *   **Faulty Sensor:** Try swapping sensor if possible.\n*   **I2C Sensors (BME/BMP/OLED) Not Found:**\n    *   **Wiring:** Check SDA and SCL connections to correct I2C pins on microcontroller. Ensure GND is connected.\n    *   **Pull-up Resistors:** I2C requires pull-up resistors on SDA/SCL lines (often built into modules, but sometimes needed externally - check module docs).\n    *   **I2C Address Conflict:** If using multiple I2C devices, ensure they have different addresses (some modules have selectable address jumpers).\n    *   **Code:** Using correct I2C address in code when initializing device?\n*   **Rain Sensor Issues:** Analog reading not changing? Digital output always high/low? Check wiring, clean sensor plate, adjust sensitivity potentiometer on module (for digital out).\n\n## Display Issues (OLED/LCD)\n\n*   **Display Blank / No Text:**\n    *   **Wiring:** Check ALL connections (VCC, GND, SDA/SCL for I2C, or multiple data/control pins for parallel LCD).\n    *   **Power:** Ensure display receives correct voltage.\n    *   **Code:** Is display initialized correctly in Setup? Using correct library and constructor (I2C address, pin numbers)? Are `display.print()` and `display.show()` (or equivalent) being called?\n    *   **Contrast (LCD):** Some LCDs have contrast potentiometer that needs adjustment.\n*   **Garbled Text:** Baud rate issue (for serial LCDs)? Incorrect library/initialization?\n\n## Connectivity Issues (IoT Board - ESP32)\n\n*   **(Wi-Fi Connection Failures):** Refer to LL-MCU-002_FAQ_v1.0 (Check SSID/Pass, Range, 2.4GHz).\n*   **Data Not Appearing on Cloud Service (ThingSpeak, etc.):**\n    *   **Wi-Fi Connected?:** Verify board connects successfully first.\n    *   **API Key:** Correct Write API Key used in code?\n    *   **URL Formatting:** Is the HTTP request URL constructed exactly as required by the cloud service API?\n    *   **Internet Access:** Does your network allow the ESP32 to reach the cloud server?\n    *   **Cloud Service Status:** Is the cloud service itself operational? Check their status page.\n    *   **Code Errors:** Check for errors during HTTP request (`urequests.get/post`) in your MicroPython code's output/REPL.\n\n## General Issues\n\n*   **Code Upload Fails:** Refer to microcontroller kit FAQs (LL-MCU-001/002/003).\n*   **System Unstable / Resetting:** Power issue (insufficient current from USB?). Check for wiring shorts.\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with model (LL-THM-001), board type, IDE/Firmware version, code, circuit diagram, and problem description."}
{"_id": "LL-THM-001_SI_v1.0", "product_id": "LL-THM-001", "product_name": "Weather Station Builder Kit", "doc_type": "Safety Information", "version": "1.0", "title": "Weather Station Builder Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# Weather Station Builder Kit Safety Information (v1.0)\n\nSafe assembly and deployment of your weather station.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (sensors, components, screws). Not for children under 3 years.**\n*   **Recommended Age:** 12+ (Requires microcontroller use and coding). Adult supervision recommended.\n*   **Electrical Safety:** Operates at safe, low DC voltage.\n    *   **Voltage Compatibility:** Follow ALL voltage compatibility guidelines for sensors, displays, and the microcontroller board (3.3V vs 5V). Incorrect voltage connections can cause permanent damage.\n    *   Power via specified USB source or compatible adapter.\n    *   Avoid short circuits during wiring.\n    *   Protect electronics from water/moisture, especially if deploying outdoors.\n*   **Outdoor Deployment:**\n    *   If placing outdoors, use a weatherproof enclosure or position the non-weatherproof components (microcontroller, breadboard) indoors with only sensor wires running outside.\n    *   Protect sensors from direct, prolonged exposure to harsh sun, heavy rain, or corrosive environments unless they are specifically rated for it.\n    *   Secure the station against wind.\n    *   Consider lightning safety if mounting high up (disconnect during storms).\n*   **Component Handling:** Handle sensors and display modules carefully. Avoid static discharge.\n\nThis kit is for educational and hobbyist weather monitoring."}
{"_id": "LL-THM-002_AM_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "Assembly Manual", "version": "1.0", "title": "Home Automation Lab Assembly Manual", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab Assembly Manual (v1.0)\n\nSetting up components for smart home experiments.\n\n## Kit Contents Overview\n\n*   Relay Module (Low voltage control, e.g., 5V coil, switches up to 24V/low current DC or potentially 120V AC **[SEE SAFETY WARNING]**)\n*   Small DC Fan (Low voltage, e.g., 5V)\n*   LED Strip Segment (Low voltage, e.g., 5V or 12V)\n*   Motion Sensor (PIR)\n*   Light Sensor Module\n*   Temperature/Humidity Sensor\n*   Breadboard & Jumper Wires\n*   Terminal Blocks / Connectors\n*   Power supply components (e.g., Barrel Jack connector, potentially separate 5V/12V adapter for peripherals)\n*   **(Microcontroller Board - e.g., KinetiCore ESP - NOT INCLUDED, SOLD SEPARATELY)**\n\n*(Illustrations of components)*\n\n## Assembly Concept\n\n*   This kit provides peripherals commonly used in home automation, intended to be controlled by a suitable microcontroller (like KinetiCore ESP - LL-MCU-002).\n*   Assembly involves wiring these peripherals to the microcontroller via a breadboard and potentially the relay module.\n\n## Wiring Peripherals (Examples - **Refer to specific component datasheets & Microcontroller Pinout**)\n\n**SAFETY FIRST: Disconnect all power before wiring! Use correct voltages!**\n\n1.  **Sensors (PIR, Light, Temp/Humid):**\n    *   Connect Sensor VCC -> Microcontroller 3.3V/5V (check sensor requirement).\n    *   Connect Sensor GND -> Microcontroller GND.\n    *   Connect Sensor Output (Digital OUT, Analog AOUT, I2C SDA/SCL) -> Appropriate Microcontroller GPIO pin (Digital Input, Analog Input, I2C pins). **Check 3.3V vs 5V signal levels!**\n    *(Diagram: Show typical sensor wiring to ESP32/Pi/Uno)*\n2.  **Low Voltage Outputs (LED Strip, DC Fan - Controlled Directly if Low Current):**\n    *   Connect Output Device GND -> Microcontroller GND.\n    *   Connect Output Device VCC -> Microcontroller 3.3V/5V (ONLY if device runs at that voltage AND draws VERY LOW current - check specs!).\n    *   **BETTER METHOD (Using Transistor/MOSFET):** For slightly higher current devices like small fans/LED strips, use a transistor (e.g., 2N2222 NPN) or MOSFET controlled by a microcontroller GPIO pin to switch the device's power from a suitable external supply (5V/12V adapter).\n        *(Diagram: Show basic transistor switching circuit)*\n3.  **Controlling Higher Power Devices (via Relay Module):**\n    *   **Relay COIL side (Low Voltage Control):**\n        *   Connect Relay Module VCC -> Microcontroller 5V (Relay coils often need 5V).\n        *   Connect Relay Module GND -> Microcontroller GND.\n        *   Connect Relay Module IN (Control Signal) -> Microcontroller GPIO Digital Output pin.\n    *   **Relay SWITCH side (Switched Circuit - **USE EXTREME CAUTION IF SWITCHING MAINS AC**):\n        *   Connect external Power Supply (+) for device to Relay COM (Common) terminal.\n        *   Connect Relay NO (Normally Open) terminal to the Device (+).\n        *   Connect Device (-) to external Power Supply (-).\n        *   **WARNING:** Wiring AC mains voltage is DANGEROUS and should only be done by qualified individuals following safety codes. For educational purposes, **stick to switching low voltage DC circuits** (e.g., a 12V light bulb powered by a 12V adapter) via the relay.\n    *(Diagram: Show relay wiring for low voltage DC load)*\n\n## Setup\n\n*   Place components on breadboard or arrange within a project box.\n*   Connect microcontroller (purchased separately) via USB for programming.\n*   Connect necessary external power supplies for peripherals (e.g., 5V for fan/LEDs, separate supply switched by relay).\n\nProceed to User Guide (UG) and programming guides (API)."}
{"_id": "LL-THM-002_UG_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "User Guide", "version": "1.0", "title": "Home Automation Lab User Guide", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab User Guide (v1.0)\n\nBuilding blocks for your smart home projects.\n\n## Overview\n\n*   This kit provides sensors (Motion, Light, Temp/Humid) and actuators (Relay for switching, Fan, LED strip) to experiment with home automation concepts.\n*   Requires a separate Wi-Fi enabled microcontroller (like KinetiCore ESP - LL-MCU-002) for control and connectivity.\n*   Control logic is implemented via programming (MicroPython/Python recommended) on the microcontroller.\n\n## Required Items (Not Included)\n\n*   KinetiCore ESP (LL-MCU-002) or similar Wi-Fi microcontroller (ESP32, Raspberry Pi).\n*   Computer for programming.\n*   USB Cable for microcontroller.\n*   (Potentially) Separate Power Supply for 5V/12V peripherals (Fan, LED strip) if microcontroller cannot supply enough current.\n\n## System Setup\n\n1.  **Wire Components:** Connect sensors and actuators to your microcontroller board as described in the Assembly Manual (AM), paying close attention to voltage levels (3.3V/5V) and using breadboard/connectors as needed.\n2.  **Program Microcontroller:** Write and upload code (MicroPython/Python) to the microcontroller to:\n    *   Read sensor values.\n    *   Implement control logic (e.g., If motion detected, turn on light via relay).\n    *   Connect to Wi-Fi.\n    *   (Optional) Set up web server, MQTT client, or connect to cloud services for remote control/monitoring.\n3.  **Connect Power:** Power the microcontroller (via USB) and any external peripherals.\n\n## Example Use Cases\n\n*   **Motion-Activated Light:** Use PIR sensor to detect motion, program microcontroller to activate Relay Module, which switches on an LED strip or low-voltage lamp.\n*   **Thermostat Fan Control:** Read Temperature/Humidity sensor. If temp exceeds threshold, activate Relay Module to turn on DC Fan.\n*   **Web-Controlled LED Strip:** Host a simple web server on the ESP32. Access web page from phone/PC browser on same network to turn LED strip ON/OFF (requires controlling LED strip power via transistor or relay).\n*   **Remote Monitoring:** Read sensor data and publish it via MQTT to a cloud dashboard (e.g., Adafruit IO) viewable from anywhere.\n*   **Light-Activated Device:** Use Light Sensor to turn on a device (via relay) when it gets dark.\n\nRefer to Experiment & Project Book (EPB) and API Reference for coding details and project ideas."}
{"_id": "LL-THM-002_EPB_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Home Automation Lab Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab Experiment & Project Book (v1.0)\n\nCreating smart interactions with code and electronics.\n\n## Introduction to Home Automation\n\n*   **Concept:** Using technology to automate and control home appliances and systems (lights, climate, security).\n*   **Key Elements:**\n    *   *Sensors:* Detect environmental conditions or events (motion, light, temp).\n    *   *Actuators:* Perform actions (switch lights/fans via relays).\n    *   *Controller (Microcontroller):* Runs the logic connecting sensors to actuators.\n    *   *Connectivity (Wi-Fi/Bluetooth):* Enables remote monitoring and control.\n*   **This Kit:** Provides basic sensors and actuators to learn the fundamentals.\n\n## Experiment 1: Motion Detection (PIR Sensor)\n\n*   **Goal:** Print message when motion is detected.\n*   **Circuit:** Wire PIR sensor (VCC, GND, OUT) to microcontroller (e.g., 5V/GND, GPIO Digital In).\n*   **Code:** (MicroPython/Python) In a loop, read the digital input pin connected to PIR OUT. If HIGH, print \"Motion Detected!\". Include delays.\n*   **Observe:** Wave hand in front of sensor. See message printed.\n\n## Experiment 2: Relay Control\n\n*   **Goal:** Turn an LED ON/OFF using the relay module controlled by the microcontroller.\n*   **Circuit:**\n    *   *Control Side:* Relay VCC->5V, Relay GND->GND, Relay IN->Microcontroller GPIO Digital Out.\n    *   *Switched Side (Low Voltage Example):* Separate 5V Supply (+) -> Relay COM. Relay NO -> LED(+) (with resistor) -> LED(-) -> Separate 5V Supply (-).\n    *(Diagram of this low-voltage relay circuit)*\n*   **Code:** (MicroPython/Python) In Setup, set GPIO pin connected to Relay IN as OUTPUT. In Loop, set pin HIGH to activate relay (closing NO contact, LED ON), set pin LOW to deactivate relay (opening NO contact, LED OFF). Add delays.\n*   **Observe:** LED turns on/off as GPIO pin state changes. Hear relay click.\n\n## Experiment 3: Light-Dependent Relay\n\n*   **Goal:** Turn on LED via relay when it gets dark.\n*   **Circuit:** Combine Light Sensor circuit (e.g., photoresistor voltage divider connected to Analog In) and Relay+LED circuit.\n*   **Code:** Read analog value from light sensor. If value exceeds dark threshold, set Relay control pin HIGH. Else, set LOW.\n*   **Observe:** Cover light sensor; LED connected to relay should turn ON.\n\n## Experiment 4: Temperature-Controlled Fan\n\n*   **Goal:** Turn on DC Fan via relay when temperature rises.\n*   **Circuit:** Combine Temp Sensor circuit (DHT or BME280) and Relay circuit switching power to the DC Fan (using appropriate external power supply for fan).\n*   **Code:** Read temperature. If temp > threshold, activate relay. Else, deactivate.\n*   **Observe:** Warm sensor; fan connected to relay should turn ON.\n\n## Project: Simple Web Control Panel (Requires ESP32/Pi)\n\n*   **Goal:** Control Relay/LED and view Sensor Data from a web browser on the same network.\n*   **Code:** (Advanced)\n    *   Connect ESP32/Pi to Wi-Fi.\n    *   Set up sensors and relay control pins.\n    *   Import `socket` (MicroPython) or `flask` (Python on Pi) library.\n    *   Create simple web server code:\n        *   Handles requests for `/` (main page): Returns HTML with current sensor data and buttons for 'LED ON', 'LED OFF'.\n        *   Handles requests for `/ledon`: Activates relay GPIO.\n        *   Handles requests for `/ledoff`: Deactivates relay GPIO.\n    *   Continuously read sensors and update data to be served.\n*   **Access:** Find board's IP address. Open web browser on phone/PC connected to same network, go to `http://<board_ip>`.\n\n## Project: MQTT Smart Node\n\n*   **Goal:** Publish sensor data to cloud MQTT broker, subscribe to command topic to control relay.\n*   **Code:** (Advanced)\n    *   Connect ESP32/Pi to Wi-Fi.\n    *   Import `umqtt.simple` (MicroPython) or `paho-mqtt` (Python on Pi).\n    *   Connect to MQTT broker (e.g., Adafruit IO, HiveMQ).\n    *   Set up callback function to handle incoming messages on command topic (e.g., `home/light/set`).\n    *   Subscribe to command topic.\n    *   In main loop: Read sensors, publish data to status topic (e.g., `home/sensors/data`), check for incoming MQTT messages (`client.check_msg()`).\n\nExplore building your own simple smart devices!"}
{"_id": "LL-THM-002_API_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "MicroPython/Python API Reference Examples", "version": "1.0", "title": "Home Automation Lab API Reference Examples", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab API Reference Examples (v1.0)\n\nCode examples for controlling Home Automation Lab components.\n\n**(Note: Assumes KinetiCore ESP/Pi board used as controller. Uses MicroPython/Python syntax. Requires libraries installed. Check pin numbers & voltage levels!)**\n\n## Reading Sensors\n\n*   **PIR Motion Sensor (Digital Input):** (See LL-SNS-002_API_v1.0)\n*   **Light Sensor (Photoresistor - Analog Input):** (See LL-THM-001_API_v1.0 - Analog Read section)\n*   **Temperature/Humidity Sensor (DHT/BME280):** (See LL-SNS-001_API_v1.0)\n\n## Controlling Outputs via GPIO\n\n```python\n# MicroPython Example\nimport machine\n\n# Example: Control LED Strip connected via NPN Transistor/MOSFET\nled_control_pin = 15 \nled_pin = machine.Pin(led_control_pin, machine.Pin.OUT)\n\nled_pin.on() # Turn LED strip ON (assuming HIGH activates transistor)\n# led_pin.off() # Turn LED strip OFF\n\n# Example: Control Relay Module (Coil connected to GPIO)\nrelay_control_pin = 16\nrelay_pin = machine.Pin(relay_control_pin, machine.Pin.OUT)\n\nrelay_pin.on() # Activate relay (Close NO contact)\n# relay_pin.off() # Deactivate relay (Open NO contact)\n```\n\n```python\n# Python (Raspberry Pi) Example\nfrom gpiozero import OutputDevice, LED, Button # etc.\n\n# Example: Control LED Strip via Transistor/MOSFET\nled_pin = OutputDevice(15) # GPIO 15\nled_pin.on()\n# led_pin.off()\n\n# Example: Control Relay Module\nrelay_pin = OutputDevice(16) # GPIO 16\nrelay_pin.on()\n# relay_pin.off()\n```\n\n## Web Server Control Snippet (MicroPython on ESP32 using Sockets)\n\n```python\nimport socket\nimport machine\n# ... (Assume Wi-Fi connected, relay_pin defined) ...\n\naddr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\ns = socket.socket()\ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\ns.bind(addr)\ns.listen(1)\n\nprint('Web server listening on port 80...')\n\nwhile True:\n    conn, addr = s.accept()\n    print('Got connection from %s' % str(addr))\n    request = conn.recv(1024)\n    request = str(request)\n    print('Content = %s' % request)\n    \n    # Check URL path\n    led_on = request.find('/?led=on')\n    led_off = request.find('/?led=off')\n    \n    if led_on == 6: # Check if path is exactly '/?led=on'\n        print('LED ON')\n        relay_pin.on()\n    if led_off == 6:\n        print('LED OFF')\n        relay_pin.off()\n        \n    # Send HTML response\n    state = \"ON\" if relay_pin.value() == 1 else \"OFF\"\n    html = f\"\"\"\n        <html><body><h1>ESP32 Relay Control</h1>\n        <p>Relay is currently {state}</p>\n        <p><a href=\\\"/?led=on\\\"><button>Turn ON</button></a></p>\n        <p><a href=\\\"/?led=off\\\"><button>Turn OFF</button></a></p>\n        </body></html>\n        \"\"\"\n    conn.send('HTTP/1.1 200 OK\\n')\n    conn.send('Content-Type: text/html\\n')\n    conn.send('Connection: close\\n\\n')\n    conn.sendall(html)\n    conn.close()\n```\n\n## MQTT Control Snippet (MicroPython on ESP32 using umqtt.simple)\n\n```python\nfrom umqtt.simple import MQTTClient\nimport machine\nimport time\n# ... (Assume Wi-Fi connected, relay_pin defined) ...\n\nmqtt_server = 'your_mqtt_broker_address' # E.g., Adafruit IO, HiveMQ\nmqtt_port = 1883\nclient_id = 'esp32_home_lab'\ntopic_sub = b'home/light/set' # Topic to listen for commands\ntopic_pub = b'home/light/status' # Topic to publish status\n\nlast_msg_time = 0\n\ndef sub_cb(topic, msg):\n    print(f\"Received Topic: {topic}, Message: {msg}\")\n    if topic == topic_sub:\n        if msg == b'ON' or msg == b'1':\n            print('Turning Relay ON')\n            relay_pin.on()\n        elif msg == b'OFF' or msg == b'0':\n            print('Turning Relay OFF')\n            relay_pin.off()\n        # Publish status update after command\n        client.publish(topic_pub, b'ON' if relay_pin.value() else b'OFF')\n\nclient = MQTTClient(client_id, mqtt_server, port=mqtt_port)\nclient.set_callback(sub_cb)\n\ntry:\n    client.connect()\n    print(f'Connected to {mqtt_server} MQTT broker')\n    client.subscribe(topic_sub)\n    print(f'Subscribed to {topic_sub.decode()}')\n    # Publish initial state\n    client.publish(topic_pub, b'ON' if relay_pin.value() else b'OFF')\nexcept OSError as e:\n    print('Failed to connect to MQTT broker.')\n    # Add reset/retry logic\n\nwhile True:\n    try:\n        # Check for incoming messages non-blockingly\n        client.check_msg()\n        \n        # Publish status periodically (optional)\n        # if time.ticks_diff(time.ticks_ms(), last_msg_time) > 60000: # Every 60s\n        #     client.publish(topic_pub, b'ON' if relay_pin.value() else b'OFF')\n        #     last_msg_time = time.ticks_ms()\n            \n        time.sleep_ms(100)\n        \n    except OSError as e:\n        print('MQTT connection error. Reconnecting...')\n        # Add reconnect logic\n        time.sleep(5)\n```\n\n**Consult specific library documentation for detailed API calls and error handling.**"}
{"_id": "LL-THM-002_FAQ_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "Troubleshooting FAQ", "version": "1.0", "title": "Home Automation Lab Troubleshooting FAQ", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab Troubleshooting FAQ (v1.0)\n\nDebugging your smart home experiments.\n\n## General Issues\n\n*   **(Microcontroller Not Detected / Upload Fails / Sensor Issues):** Refer to FAQs for the specific microcontroller kit being used (LL-MCU-001/002/003) and sensor packs (LL-SNS-001/002).\n*   **(Wi-Fi/Network Issues):** Refer to LL-MCU-002 FAQ (IoT Kit).\n\n## Relay Module Issues\n\n*   **Relay Not Clicking / Activating:**\n    *   **Control Signal Wiring:** Check connection from Microcontroller GPIO OUT pin to Relay Module IN pin.\n    *   **Relay Power:** Ensure Relay Module VCC and GND are connected to the correct voltage source (Often 5V, check module spec!) from the microcontroller or a separate supply.\n    *   **Code Logic:** Verify code is actually setting the control GPIO pin HIGH/LOW correctly.\n    *   **Insufficient Microcontroller Current:** Some relays need more current on the IN pin than a microcontroller GPIO can supply directly. May need a transistor driver circuit between GPIO and Relay IN pin.\n    *   **Faulty Relay Module.**\n*   **Relay Clicks, But Switched Device Doesn't Turn On/Off:**\n    *   **Switched Circuit Wiring:** Double-check wiring on the high-voltage/load side (COM, NO/NC terminals). Is the external power supply for the device connected and ON?\n    *   **Using Correct Terminals:** Are you using the Normally Open (NO) terminal for a device you want ON when relay is active, or Normally Closed (NC) for a device you want OFF when relay is active?\n    *   **Faulty Switched Device:** Is the LED/Fan/Light itself working?\n    *   **Relay Contact Failure:** Internal contacts might be damaged (less common).\n*   **Relay Buzzing:** Some AC relays might buzz slightly, but excessive buzzing on DC control could indicate power issue or faulty relay.\n\n## Output Device Issues (Fan, LED Strip)\n\n*   **Device Not Turning On:**\n    *   **Power Supply:** Does the device have its own power supply connected correctly? Is it the correct voltage (5V, 12V)?\n    *   **Control Method:**\n        *   *If via Relay:* Is the relay activating correctly (see above)?\n        *   *If via Transistor/MOSFET:* Check transistor wiring (Base/Gate to Microcontroller GPIO via resistor, Collector/Drain to Device Load, Emitter/Source to GND). Is transistor rated for the device current? Possible faulty transistor.\n        *   *If Direct GPIO (LOW CURRENT ONLY):* Check GPIO pin state in code. Is device compatible with direct GPIO drive (very low mA)?\n\n## Integration & Logic Issues\n\n*   **Automation Not Triggering Correctly (e.g., Light doesn't turn on with motion):**\n    *   **Sensor Issue:** Is the sensor (PIR) actually detecting motion and sending the correct signal (HIGH/LOW) to the microcontroller input pin?\n    *   **Code Logic:** Check the `If/Else` statement in your code. Is the condition (e.g., `pir_pin.value() == 1`) correct? Is the action inside the `If` block correct (e.g., activating the correct relay pin)?\n    *   **Timing:** Is there a delay preventing immediate reaction? Does PIR need time to reset?\n*   **Web/MQTT Control Not Working:**\n    *   **(Network Issues):** Refer to LL-MCU-002 FAQ.\n    *   **Code Logic:** Is the web server/MQTT callback function correctly identifying the command (e.g., `/ledon`, MQTT message 'ON') and toggling the correct GPIO pin?\n    *   **Device State:** Is the device trying to control already in that state?\n\n## Contacting Support\n\n*   Visit Kinetic Constructs support with kit model (LL-THM-002), microcontroller model, IDE/Firmware version, code, circuit diagram, and detailed problem description."}
{"_id": "LL-THM-002_SI_v1.0", "product_id": "LL-THM-002", "product_name": "Home Automation Lab", "doc_type": "Safety Information", "version": "1.0", "title": "Home Automation Lab Safety Information", "language": "en-US", "format": "Markdown", "text": "# Home Automation Lab Safety Information (v1.0)\n\nSafe practices for home automation experiments.\n\n*   **WARNING: CHOKING HAZARD -- Small parts. Not for children under 3 years.**\n*   **Recommended Age:** 13+ Requires understanding of electronics, coding, and potentially household wiring concepts (for advanced use). **Significant Adult Supervision REQUIRED if dealing with AC Mains voltage.**\n*   **Electrical Safety (Low Voltage):** Microcontroller, sensors, fans, LED strips typically operate at safe low DC voltages (3.3V, 5V, 12V).\n    *   Follow voltage compatibility rules strictly when connecting components.\n    *   Use appropriate power supplies for each component's voltage/current requirements.\n    *   Avoid short circuits.\n    *   Protect from liquids.\n*   **RELAY MODULE SAFETY - HIGH VOLTAGE WARNING:**\n    *   Relay modules included in hobbyist kits CAN often physically switch AC Mains voltages (e.g., 120V/240V AC).\n    *   **HOWEVER, WIRING AC MAINS VOLTAGE IS EXTREMELY DANGEROUS AND CAN CAUSE SEVERE ELECTRICAL SHOCK, FIRE, OR DEATH IF DONE INCORRECTLY.**\n    *   **IT IS STRONGLY RECOMMENDED THAT BEGINNERS AND EDUCATIONAL USERS **DO NOT** USE THESE RELAY MODULES TO SWITCH AC MAINS VOLTAGE.**\n    *   **ONLY** qualified individuals with thorough understanding of electrical codes and safety practices should attempt to wire AC mains through these relays, and ONLY within a properly grounded and insulated project enclosure.\n    *   For educational purposes, **use the relay ONLY to switch safe, low-voltage DC circuits** (e.g., turning a 12V lamp ON/OFF using a separate 12V DC power supply).\n*   **Component Handling:** Handle components carefully. Avoid static discharge.\n*   **Network Security:** If connecting projects to your home network/internet, follow network security best practices (strong passwords, secure services).\n\n**Prioritize safety, especially when dealing with components like relays that *could* be used with dangerous voltages. Stick to low-voltage experiments unless properly qualified.**"}
{"_id": "LL-BRD-001_UG_v1.0", "product_id": "LL-BRD-001", "product_name": "Breadboard Basics Kit", "doc_type": "User Guide", "version": "1.0", "title": "Breadboard Basics Kit User Guide", "language": "en-US", "format": "Markdown", "text": "# Breadboard Basics Kit User Guide (v1.0)\n\nYour first steps into building electronic circuits.\n\n## Kit Contents Overview\n\n*   Half-Size Breadboard\n*   Battery Pack (e.g., 4xAA holder with connector wires)\n*   Jumper Wires (Assorted lengths/colors, Male-Male)\n*   LEDs (Red, Green, Yellow)\n*   Resistors (Common values like 220Ω, 1kΩ, 10kΩ - learn color codes!)\n*   Push Buttons (Tactile Switches)\n\n*(Illustrations: Breadboard layout, components)*\n\n## Understanding the Breadboard\n\n*(Diagram: Breadboard showing connected rows and power rails)*\n\n*   **No Soldering:** Allows easy, temporary connections.\n*   **Terminal Strips (Rows):** The main area has rows of 5 holes each. All 5 holes in a single horizontal row are electrically connected internally.\n*   **Center Divide:** The gap down the middle separates the left rows from the right rows.\n*   **Power Rails (Columns):** The long strips along the sides are usually connected vertically. Typically marked with Red (+) and Blue/Black (-) lines. Use these to distribute power from the battery pack.\n\n## Identifying Components\n\n*   **LEDs:** Light Emitting Diodes. Have polarity. Long leg = Anode (+), Short leg = Cathode (-). Need a current-limiting resistor.\n*   **Resistors:** Limit current. Value identified by color bands (use online calculator or chart). No polarity.\n*   **Push Buttons:** Tactile switches that make a connection between legs when pressed. Often designed to straddle the center divide.\n*   **Jumper Wires:** Connect components or rails together.\n*   **Battery Pack:** Provides power (e.g., 4xAA ~ 6V). Red wire = Positive (+), Black wire = Negative (-)/Ground (GND).\n\n## Building Your First Circuit: Simple LED Light\n\n1.  **Insert Batteries:** Put AA batteries into the Battery Pack.\n2.  **Power the Rails:**\n    *   Insert the Red wire from the battery pack into any hole along the Red (+) power rail on the breadboard.\n    *   Insert the Black wire into any hole along the Blue (-) power rail.\n3.  **Place Components:**\n    *   Insert an LED into the breadboard rows (e.g., long leg in row 10, short leg in row 11).\n    *   Insert a 220Ω resistor (Red-Red-Brown-Gold bands) so one leg is in the SAME row as the LED's long leg (row 10) and the other leg is in a different empty row (e.g., row 15).\n4.  **Wire Connections:**\n    *   Use a jumper wire to connect from the Red (+) power rail to the resistor's free leg (row 15).\n    *   Use a jumper wire to connect from the LED's short leg row (row 11) to the Blue (-) power rail (GND).\n    *(Diagram: Shows this circuit clearly on the breadboard)*\n5.  **Check:** If wired correctly, the LED should light up! If not, double-check polarity of LED and battery connections, ensure resistor is connected correctly.\n\n## Building with Buttons\n*   To add a button, place it straddling the center divide.\n*   Wire power (+) rail to one side of the button.\n*   Wire the other side of the button to your LED/resistor circuit.\n*   Now the LED only lights when the button is pressed, completing the circuit.\n\nRefer to the Experiment & Project Book (EPB) for more circuit examples."}
{"_id": "LL-BRD-001_EPB_v1.0", "product_id": "LL-BRD-001", "product_name": "Breadboard Basics Kit", "doc_type": "Experiment & Project Book", "version": "1.0", "title": "Breadboard Basics Experiment & Project Book", "language": "en-US", "format": "Markdown", "text": "# Breadboard Basics Experiment & Project Book (v1.0)\n\nExploring simple circuits without programming.\n\n## Introduction\n\n*   Learn fundamental electronic concepts: circuits, voltage, current, resistance.\n*   Practice building circuits on a breadboard.\n\n## Experiment 1: Series Circuit (Multiple LEDs)\n\n*   **Goal:** Connect two LEDs so they both light up from one power source.\n*   **Circuit:** Battery Pack (+) Rail -> Resistor (e.g., 100-220Ω) -> LED1 Anode(+), LED1 Cathode(-) -> LED2 Anode(+), LED2 Cathode(-) -> Battery Pack (-) Rail.\n    *(Diagram: Shows components connected one after another in a single loop)*\n*   **Observe:** Both LEDs should light up, possibly dimmer than a single LED because they share the voltage.\n*   **Concept:** In a series circuit, current flows through each component sequentially. If one LED breaks/is removed, the circuit is broken, and neither lights.\n\n## Experiment 2: Parallel Circuit (Multiple LEDs)\n\n*   **Goal:** Connect two LEDs so they light up independently.\n*   **Circuit:**\n    *   Branch 1: (+) Rail -> Resistor1 -> LED1 Anode, LED1 Cathode -> (-) Rail.\n    *   Branch 2: (+) Rail -> Resistor2 -> LED2 Anode, LED2 Cathode -> (-) Rail.\n    *   (Use separate resistor for each LED! e.g., 220Ω each).\n    *(Diagram: Shows two separate loops connected to the same power rails)*\n*   **Observe:** Both LEDs should light up brightly. Try removing one LED - the other should stay lit.\n*   **Concept:** In a parallel circuit, current splits and flows through each branch independently.\n\n## Experiment 3: Button Control\n\n*   **Goal:** Use a button to turn an LED on/off.\n*   **Circuit:** (+) Rail -> Button Leg 1. Button Leg 2 (opposite side) -> Resistor -> LED Anode, LED Cathode -> (-) Rail.\n    *(Diagram: Shows button interrupting the circuit path)*\n*   **Observe:** LED is OFF normally. Pressing the button completes the circuit, turning the LED ON.\n\n## Experiment 4: Two Buttons & Logic (Simple AND)\n\n*   **Goal:** LED turns ON only if Button A AND Button B are pressed.\n*   **Circuit:** (+) Rail -> Button A Leg 1. Button A Leg 2 -> Button B Leg 1. Button B Leg 2 -> Resistor -> LED Anode, LED Cathode -> (-) Rail.\n    *(Diagram: Shows buttons connected in series)*\n*   **Observe:** You must press both buttons simultaneously for the LED to light.\n*   **Concept:** Buttons connected in series act like a logical AND - both must be closed for current to flow.\n\n## Experiment 5: Two Buttons & Logic (Simple OR)\n\n*   **Goal:** LED turns ON if Button A OR Button B (or both) are pressed.\n*   **Circuit:**\n    *   Branch A: (+) Rail -> Button A Leg 1. Button A Leg 2 -> Junction Point.\n    *   Branch B: (+) Rail -> Button B Leg 1. Button B Leg 2 -> SAME Junction Point.\n    *   Junction Point -> Resistor -> LED Anode, LED Cathode -> (-) Rail.\n    *(Diagram: Shows buttons in parallel, both feeding the LED circuit)*\n*   **Observe:** Pressing either button (or both) will light the LED.\n*   **Concept:** Buttons connected in parallel act like a logical OR - closing either path completes the circuit.\n\n## Resistor Color Codes\n*(Include a basic chart showing common resistor color bands and values found in the kit, e.g., 220Ω, 1kΩ, 10kΩ)*\n\nKeep experimenting and building!"}
{"_id": "LL-BRD-001_SI_v1.0", "product_id": "LL-BRD-001", "product_name": "Breadboard Basics Kit", "doc_type": "Safety Information", "version": "1.0", "title": "Breadboard Basics Kit Safety Information", "language": "en-US", "format": "Markdown", "text": "# Breadboard Basics Kit Safety Information (v1.0)\n\nSafe handling of breadboard components.\n\n*   **WARNING: CHOKING HAZARD -- Small parts (LEDs, resistors, wires, buttons). Not for children under 3 years.**\n*   **Recommended Age:** 8+ Adult supervision recommended.\n*   **Battery Safety:** Follow standard battery safety guidelines for AA batteries used in the Battery Pack (correct type, polarity, do not mix, remove when storing).\n*   **Electrical Safety:** This is a low-voltage kit operating from batteries. Components are generally safe to handle.\n    *   Avoid short circuits (connecting (+) rail directly to (-) rail with a wire) - this can drain batteries quickly and potentially overheat wires or battery pack.\n    *   Use resistors with LEDs as instructed to prevent LED burnout.\n    *   Do not connect to wall power outlets.\n    *   Avoid contact with water.\n*   **Component Handling:** Insert component leads and jumper wires gently into breadboard. Leads are thin and can bend easily. LEDs have polarity.\n*   Keep small parts away from pets."}
{"_id": "LL-BRD-002_CGPL_v1.0", "product_id": "LL-BRD-002", "product_name": "Component Cornucopia Pack", "doc_type": "Component Guide & Parts List", "version": "1.0", "title": "Component Cornucopia Pack Guide & Parts List", "language": "en-US", "format": "Markdown", "text": "# Component Cornucopia Pack Guide & Parts List (v1.0)\n\nAn assortment of electronic components for breadboarding.\n\n## Introduction\n\n*   This pack provides a wide variety of common electronic components for experimenting with circuits, designed for use with breadboards and microcontroller kits.\n*   Requires basic knowledge of component identification (reading values, polarity).\n\n## Parts List (Example Assortment - **Actual contents may vary**)\n\n*(Categorized table format recommended)*\n\n**Resistors (Carbon Film, 1/4W):**\n| Value      | Color Bands              | Quantity |\n| :--------- | :----------------------- | :------- |\n| 100Ω       | Brown-Black-Brown-Gold   | 10       |\n| 220Ω       | Red-Red-Brown-Gold       | 10       |\n| 330Ω       | Orange-Orange-Brown-Gold | 10       |\n| 1kΩ        | Brown-Black-Red-Gold     | 10       |\n| 4.7kΩ      | Yellow-Violet-Red-Gold   | 10       |\n| 10kΩ       | Brown-Black-Orange-Gold  | 10       |\n| 100kΩ      | Brown-Black-Yellow-Gold  | 10       |\n| 1MΩ        | Brown-Black-Green-Gold   | 10       |\n\n**Capacitors:**\n| Type            | Value       | Markings (Example) | Quantity |\n| :-------------- | :---------- | :----------------- | :------- |\n| Ceramic Disc    | 100nF (0.1uF)| 104                | 10       |\n| Ceramic Disc    | 22pF        | 22                 | 10       |\n| Electrolytic    | 10uF        | 10uF, Voltage, (-) | 5        |\n| Electrolytic    | 100uF       | 100uF, Voltage, (-)| 5        |\n*Note: Electrolytic capacitors HAVE POLARITY (Negative stripe indicates negative lead).*\n\n**Diodes & LEDs:**\n| Type            | Description                  | Quantity |\n| :-------------- | :--------------------------- | :------- |\n| Diode (1N4001)  | Rectifier Diode (Stripe=Cathode) | 5        |\n| LED - Red 5mm   | Light Emitting Diode         | 10       |\n| LED - Green 5mm | Light Emitting Diode         | 10       |\n| LED - Yellow 5mm| Light Emitting Diode         | 10       |\n| LED - Blue 5mm  | Light Emitting Diode         | 5        |\n| LED - RGB       | Common Cathode/Anode (4 legs)| 2        |\n*Note: LEDs have polarity (Long lead=Anode +, Short=Cathode -).*\n\n**Transistors:**\n| Type            | Description             | Quantity |\n| :-------------- | :---------------------- | :------- |\n| NPN (2N2222/PN2222)| BJT General Purpose     | 5        |\n| PNP (2N2907/PN2907)| BJT General Purpose     | 5        |\n| MOSFET (BS170)  | N-Channel Logic Level   | 3        |\n*Note: Check pinout (EBC / GDS) carefully for each type.*\n\n**Integrated Circuits (ICs):**\n| Type        | Description          | Quantity |\n| :---------- | :------------------- | :------- |\n| 555 Timer   | Timer/Oscillator IC  | 2        |\n| LM741/TL071 | Operational Amplifier| 2        |\n| 74HC595     | Shift Register       | 1        |\n*Note: ICs have notch/dot indicating Pin 1. Check datasheet for pin functions.*\n\n**Sensors & Input/Output:**\n| Type             | Description                | Quantity |\n| :--------------- | :------------------------- | :------- |\n| Push Button      | Tactile Switch             | 10       |\n| Potentiometer    | 10kΩ Variable Resistor     | 2        |\n| Photoresistor    | Light Dependent Resistor   | 3        |\n| Temp Sensor(TMP36)| Analog Temperature Sensor  | 1        |\n| Buzzer (Passive) | Requires AC signal/PWM     | 1        |\n| Buzzer (Active)  | Beeps with DC voltage      | 1        |\n\n**Other:**\n| Type            | Description                | Quantity |\n| :-------------- | :------------------------- | :------- |\n| Jumper Wires    | Assorted M-M, M-F, F-F     | 1 pack   |\n| Breadboard      | Full or Half Size          | 1        |\n\n## Component Identification Tips\n\n*   **Resistors:** Use color code charts/apps.\n*   **Capacitors:** Read printed value and voltage. Note polarity on electrolytics.\n*   **Diodes/LEDs:** Note polarity (stripe on diode, leg length on LED).\n*   **Transistors/ICs:** Read part number printed on component. Look up datasheet online for pinout and specifications.\n\nOrganize components for easy access (e.g., using small labeled bags or compartment box)."}
{"_id": "LL-BRD-002_SI_v1.0", "product_id": "LL-BRD-002", "product_name": "Component Cornucopia Pack", "doc_type": "Safety Information", "version": "1.0", "title": "Component Cornucopia Pack Safety Information", "language": "en-US", "format": "Markdown", "text": "# Component Cornucopia Pack Safety Information (v1.0)\n\nSafe handling of electronic components.\n\n*   **WARNING: CHOKING HAZARD -- Contains numerous small electronic components. Keep away from children under 3 years and pets.**\n*   **Recommended Use:** Ages 10+ with understanding of basic electronics or adult supervision.\n*   **Electrical Safety:** These are individual components intended for low-voltage DC circuits (typically 3.3V - 12V, depending on component rating).\n    *   **Voltage Ratings:** Pay attention to maximum voltage ratings, especially for capacitors (electrolytics) and ICs. Exceeding ratings can cause component failure or damage.\n    *   **Polarity:** Connect polarized components (LEDs, electrolytic capacitors, diodes, ICs) with the correct polarity (+/-). Reversing polarity can destroy the component.\n    *   **Current Limits:** Use appropriate current-limiting resistors for LEDs. Do not exceed current ratings for transistors or IC outputs.\n    *   **Avoid Short Circuits:** Double-check wiring on breadboard before applying power.\n    *   **Static Discharge (ESD):** Some components (ICs, MOSFETs) are sensitive to static. Handle carefully, ground yourself before touching.\n*   **Component Handling:**\n    *   Component leads are often thin and can bend/break easily.\n    *   Do not overheat components if soldering (not intended for solderless breadboard use, but applicable if used elsewhere).\n    *   ICs have specific pinouts - always refer to the datasheet.\n*   **Storage:** Keep components organized (e.g., in provided packaging or compartment box) to prevent lead bending and make identification easier.\n\nThis pack contains components for building and experimenting with electronic circuits. Follow standard electronics handling precautions."}
{"_id": "LL-EDU-001_EG_v1.0", "product_id": "LL-EDU-001", "product_name": "Logic Lab Classroom Set (Set of 5)", "doc_type": "Educator Guide", "version": "1.0", "title": "Logic Lab Classroom Set Educator Guide", "language": "en-US", "format": "Markdown", "text": "# Logic Lab Classroom Set Educator Guide (v1.0)\n\nTeaching Digital Logic Fundamentals with Circuit City Logic Lab\n\n## Kit Overview\n\n*   **Contents:** 5x LL-CIR-005 Circuit City Logic Lab kits, this guide.\n*   **Target Audience:** Grades 4-8 (Ages 9-14)\n*   **Focus Areas:** Digital Logic Gates (AND, OR, NOT, XOR), Truth Tables, Boolean Algebra Introduction, Circuit Building, Troubleshooting, Simulation Software Usage.\n*   **Time Estimate:** Multiple sessions (Intro + Basic Gates + Combinations + Simulation).\n*   **Required:** 5x Computers (Windows/Mac) with USB ports and 'Circuit City Simulator' software installed.\n\n## Learning Objectives\n\n*   Students will identify common logic gate symbols (AND, OR, NOT, XOR).\n*   Students will construct truth tables for basic logic gates.\n*   Students will build physical logic circuits using modular blocks and wires.\n*   Students will predict the output of simple combinational logic circuits.\n*   Students will use simulation software to build and test virtual logic circuits.\n*   Students will relate physical circuit behavior to simulated behavior.\n*   Students will troubleshoot simple logic circuit errors (wiring, incorrect logic).\n*   Students will be introduced to Boolean expressions representing logic circuits.\n\n## Preparation\n\n*   **Materials:** Ensure all 5 kits are complete. Install Circuit City Simulator software on 5 computers. Test hardware detection via USB for each kit/computer station.\n*   **Space:** Table space for hardware circuit building, computer stations for simulation.\n*   **Grouping:** Plan small groups (2-3 students) per kit/computer.\n*   **Familiarization:** Work through the basic experiments (LL-CIR-005 EPB) and simulator (LL-CIR-005 SWG) yourself.\n\n## Lesson Plan / Activity Ideas (Modular)\n\n**Module 1: Introduction & Basic Gates (Hardware Focus)**\n\n1.  **Discussion (10-15 min):** What is digital? (ON/OFF, 1/0). Introduce logic gates as decision-makers.\n2.  **Hardware Intro (15 min):** Explain kit components (Power, Input, Output, Gate modules, Wiring).\n3.  **Build & Test NOT, AND, OR (45-60 min):** Guide groups through building and testing circuits for NOT, AND, and OR gates using physical blocks (refer to LL-CIR-001/005 EPB). Emphasize creating truth tables by testing all input combinations.\n4.  **Introduce XOR (15 min):** Explain XOR logic. Groups build and test XOR circuit physically.\n\n**Module 2: Simulation & Combining Gates**\n\n1.  **Introduce Simulator (15-20 min):** Guide students through launching software, connecting hardware (optional for sim-only), dragging components, wiring virtually (refer to LL-CIR-005 SWG).\n2.  **Recreate Basic Gates in Sim (20 min):** Have groups build NOT, AND, OR, XOR circuits in the simulator and verify behavior using virtual inputs/outputs.\n3.  **Combining Gates Challenge 1 (20-30 min):** Challenge: Build `(A AND B) OR C`. Groups design and test in simulator first, then optionally build physically.\n4.  **Combining Gates Challenge 2 (20-30 min):** Challenge: Build `NOT (A AND B)`. (This is a NAND gate). Compare its truth table to AND.\n\n**Module 3: Design Problems**\n\n1.  **Problem 1: Majority Vote (30-45 min):** Design a circuit with 3 inputs (A, B, C) where the output LED turns ON if two OR MORE inputs are ON. (Hint: Needs multiple AND and OR gates). Simulate first.\n2.  **Problem 2: Simple Security System (30-45 min):** Design a circuit where a Buzzer sounds if a 'Door Sensor' (Button 1) is ON AND an 'Alarm Active' switch (Button 2) is ON. Simulate and build.\n\n**Module 4: Tutorials & Challenges (Software Focus)**\n\n1.  **Guided Exploration (Ongoing):** Have students work through built-in tutorials or challenges within the Circuit City Simulator software at their own pace.\n\n## Classroom Management\n\n*   **Pairing:** Pair students with complementary skills if possible (one strong builder, one strong computer user).\n*   **Wiring:** Emphasize careful, neat wiring. Color-coding wires (if available) helps.\n*   **Troubleshooting:** Encourage systematic debugging: Check power? Check signal wires? Correct gate? Simulate first?\n\n## Curriculum Connections\n\n*   **Computer Science:** Digital Logic Fundamentals, Boolean Algebra, Algorithms (circuit design).\n*   **Technology & Engineering:** Circuit Building, Simulation, Troubleshooting.\n*   **Math:** Binary Numbers (implicit), Logic.\n\nRefer to individual product documents (UG, EPB, SWG, FAQ, SI) for LL-CIR-005 for detailed technical information."}
{"_id": "LL-EDU-002_EG_v1.0", "product_id": "LL-EDU-002", "product_name": "MicroController Innovator Pack (Set of 5)", "doc_type": "Educator Guide", "version": "1.0", "title": "MicroController Innovator Pack Educator Guide", "language": "en-US", "format": "Markdown", "text": "# MicroController Innovator Pack Educator Guide (v1.0)\n\nTeaching Coding & Electronics with KinetiCore Uno\n\n## Kit Overview\n\n*   **Contents:** 5x LL-MCU-001 MicroController Starter Kits (KinetiCore Uno board, breadboard, components, USB cable), this guide.\n*   **Target Audience:** Grades 5-9 (Ages 10-15)\n*   **Focus Areas:** Introduction to Microcontrollers, Physical Computing, Block-Based Programming (Control Flow, Variables, Input/Output), Basic Electronics (Circuits, Voltage, Current, Resistance), Sensor Reading (Digital/Analog), Actuator Control (LEDs, PWM).\n*   **Time Estimate:** Multiple sessions (Setup + Basic IO + Sensors + Projects).\n*   **Required:** 5x Computers (Windows/Mac/Linux) with USB ports and 'Kinetic Blocks IDE' software installed.\n\n## Learning Objectives\n\n*   Students will identify key components of a microcontroller system (board, breadboard, components, IDE).\n*   Students will build simple electronic circuits on a breadboard connecting components to microcontroller pins.\n*   Students will install and configure the Kinetic Blocks IDE software.\n*   Students will write block-based programs involving Setup and Loop structures.\n*   Students will control digital outputs (LEDs) using code.\n*   Students will read digital inputs (buttons) using code and implement conditional logic.\n*   Students will control analog outputs (LED brightness via PWM).\n*   Students will read analog inputs (potentiometer, light sensor, temp sensor) and use sensor data in programs.\n*   Students will utilize the Serial Monitor for debugging and data display.\n*   Students will design and implement solutions to simple physical computing challenges.\n\n## Preparation\n\n*   **Materials:** Ensure all 5 kits are complete. Install Kinetic Blocks IDE on 5 computers. Test board connection and driver installation for each station.\n*   **Space:** Computer stations with adjacent space for breadboarding.\n*   **Grouping:** Plan small groups (2-3 students) per kit/computer.\n*   **Familiarization:** Work through the experiments in LL-MCU-001 EPB and understand the blocks in LL-MCU-001 BCG yourself.\n\n## Lesson Plan / Activity Ideas (Multi-Session Suggestion)\n\n**Session 1: Setup & Blinky (1-1.5 hours)**\n\n1.  **Intro (15 min):** What's a microcontroller? How is it different from a regular computer? What can it do? Introduce KinetiCore Uno and breadboard.\n2.  **Software Setup (20-30 min):** Guide students through connecting board, installing drivers (if needed), launching IDE, selecting Board/Port.\n3.  **First Program - Onboard Blink (15 min):** Load default Blink sketch. Explain Setup/Loop. Explain Digital Write, HIGH/LOW, Wait blocks. Upload and observe onboard LED.\n4.  **External LED Blink (20-30 min):** Guide students through building Exp 1 circuit (External LED on Pin 8 - LL-MCU-001 EPB). Modify block code to blink Pin 8. Upload and test.\n\n**Session 2: Inputs & Conditionals (1-1.5 hours)**\n\n1.  **Digital Input (Button) (30-45 min):** Guide students through building Exp 2 circuit (Button with pull-down resistor on Pin 2). Explain INPUT mode, Digital Read block, If/Else block. Code the 'LED ON when button pressed' logic. Upload and test.\n2.  **Discussion (10 min):** Importance of pull-down/pull-up resistors (preventing floating inputs).\n3.  **Challenge:** Modify code to make LED blink only while button is held.\n\n**Session 3: Analog Output & Input (1-1.5 hours)**\n\n1.  **Analog Output (PWM Fade) (30 min):** Guide through Exp 3 circuit (LED on PWM Pin ~9). Explain Analog Write (PWM) block and 0-255 range. Code the fading logic using loops and variables. Upload and test.\n2.  **Analog Input (Potentiometer/Photoresistor) (30-45 min):** Guide through Exp 4 circuit (Photoresistor voltage divider on A0). Explain Analog Read block and 0-1023 range. Introduce Serial Monitor. Code to read sensor and print value to Serial Monitor. Upload and observe readings change.\n3.  **Challenge:** Combine Analog Input and PWM Output - make LED brightness controlled by light sensor or potentiometer (use `Map` block).\n\n**Session 4: Sensors & Projects (Ongoing)**\n\n1.  **More Sensors/Actuators:** Introduce other components (Temp sensor, Buzzer, Servo) and corresponding blocks/experiments from EPB.\n2.  **Mini-Projects:**\n    *   *Nightlight:* Turn LED ON when light sensor reads below threshold.\n    *   *Temperature Alarm:* Sound buzzer if temp sensor exceeds threshold.\n    *   *Servo Sweeper:* Make servo sweep back and forth.\n3.  **Open Design Challenge:** Students design and build a simple interactive device using kit components.\n\n## Classroom Management & Troubleshooting\n\n*   **Pair Programming:** Encourage students to work together on coding and building.\n*   **Wiring Discipline:** Emphasize checking connections carefully. Use color-coded wires if possible.\n*   **Debugging:** Teach systematic debugging: Check wiring? Check code logic block-by-block? Use Serial Monitor prints? Simplify the circuit/code?\n*   **Refer to LL-MCU-001 FAQ for common issues.**\n\n## Curriculum Connections\n\n*   **Computer Science:** Programming Constructs (Sequence, Loop, Conditionals, Variables), Input/Output, Human-Computer Interaction.\n*   **Technology & Engineering:** Electronics, Circuits, Microcontrollers, Sensors, Actuators, Debugging, Design Process.\n*   **Science:** Measurement (Light, Temp), Electricity.\n*   **Math:** Variables, Ranges (0-255, 0-1023), Mapping.\n\nRefer to individual product documents (UG, EPB, BCG, FAQ, SI) for LL-MCU-001 for detailed technical information."}
